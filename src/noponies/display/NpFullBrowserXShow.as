/* AS3*Copyright 2008 noponies.*/package noponies.display{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Loader;	import flash.display.Sprite;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.events.TimerEvent;	import flash.net.URLRequest;	import flash.utils.Timer;	import fl.transitions.Tween;	import fl.transitions.TweenEvent;	import fl.transitions.easing.None;	import noponies.events.NpFbXShowEvent;	/**	 *  <strong>NpFbXShowEvent</strong>	 * <p>The NpFbXShowEvent Class is designed to create Full Web Browser Background Image SlideShows of bitmaps</p>	 * <p> Check the various methods and properties of the class to explore its functionality</p>	 *	<p>Configure the class user defineable vars to change its behaviour.</p>	 * <p>Class has a number of playback settings. You can set it to loop, display its passed images sequentially	 *or randomly. Set the playback to automatic, or manual. etc. To achieve this finer grained control over the class review its various properties</p>	 *	<p>This class attempts to keep memory useage down by creating bitmapdata objects from the loaded images. It then	 *runs a routine to keep track of each bitmap loaded so that they can be removed when no longer needed. At most	 *there are only ever two bitmaps in memory. As soon as a new slide is fully displayed, the old slide is removed	 *and all vars pointing to it set to null. Memory useage stays fairly low using this approach, around 20 megs or so	 *depending on the size of the images loaded in.</p>	 * <b>Author:</b> noponies - <a href="http://www.blog.noponies.com/" target="_blank">www.blog.noponies.com</a><br />	 * <b>Class version:</b> 1<br />	 * <b>Actionscript version:</b> 3.0 Player Version 9.0.28.0<br />	 * <b>Copyright:</b>	 * You can use this class how you like, except as a base for Flash Components or for Flash Template sites.<br />	 * <br />	 * <b>Date:</b> 30 July 2008<br />	 *@langversion ActionScript 3.0 	 *@playerversion 9.0.28.0	 */	public class NpFullBrowserXShow extends Sprite {		//--------------------------------------		// PRIVATE INSTANCE METHODS		//--------------------------------------		//via getters / setters		private var crossFadeTime:Number = 2;//SECONDS		private var imageTime:uint = 20;//SECONDS		private var randomXshow:Boolean = true;//random or linear slide progression		private var looping:Boolean = false;//do the slides loop?		private var autoSlides:Boolean = true;//Automatic slideshow progression (true), or Manual (false)		private var imagesArray:Array;//array of images		private var xPos:Number = 0;		private var yPos:Number = 0;		private var p:int;//counter var		private var loader:Loader;//loader for loading in images		private var slide:Sprite;//sprite that serves as a content holder for loaders content		private var slideTimer:Timer;		private var bitMapBg:Bitmap;//Bitmap		private var tweeningAlpha:Boolean = false;//are we tweening the bg alpha		private var targetSprite:Sprite;		private var loaderSwap:Boolean = false;//bool to track cycling of slideshow		private var bitDat1:BitmapData;//bitmap data holders		private var bitDat2:BitmapData;//bitmap data holders		private var fadeInc:Number;		private var LoadedBytes:Number;//loaded bytes of each slide		private var TotalBytes:Number;//total bytes of each slide		private var slidesPaused:Boolean = false;//bool to track paused state of slides		//resize class 		private var tempResize:NpFSObjectResize;		private var contentHolderResize:NpFSObjectResize;		private var inTween:Tween;		private var outTween:Tween;		private var useSeconds:Boolean = true;		//--------------------------------------		// GETTERS/SETTERS		//--------------------------------------		/**		 *	Get / Set the position relative to the browsers size (as a percentage of the browsers width) where you would like your slide to scale from on the <code>x</code> axis. This parameter is designed to allow for you to center your objects within the stage. 		 *	For instance, a value of <code>0.5</code> will cause your object to be centered on the x axis. A value of <code>0</code> will place your object hard left. This parameter is passed to the <code>NpFSObjectResize.addResizeTarget()</code>		 *	method. Review that Class for more information on this property.		 *	@see #noponies.display.NpFSObjectResize		 *	@return Number		 */		public function get slideAlignX():Number {			return xPos;		}		/**		* @private		*/		public function set slideAlignX(newxPos:Number):void {			xPos = newxPos;		}		/**		 *	Get / Set the position relative to the browsers size (as a percentage of the browsers height) where you would like your slide to scale from on the <code>y</code> axis. This parameter is designed to allow for you to center your objects within the stage. 		 *	For instance, a value of <code>0.5</code> will cause your object to be centered on the y axis. A value of <code>0</code> will place your object hard top. This parameter is passed to the <code>NpFSObjectResize.addResizeTarget()</code>		 *	method. Review that Class for more information on this property.		 *	@see #noponies.display.NpFSObjectResize		 *	@return Number		 */		public function get slideAlignY():Number {			return yPos;		}		/**		* @private		*/		public function set slideAlignY(newyPos:Number):void {			yPos = newyPos;		}		/**		 *	Get / Set (if for some reason you need to change) the array of image URLS that the slideShow pulls it's slides from. Setting this property does not negate the need to pass in an array of image URL's		 *	Class constructor.		 *	@default Array passed in via constructor argument.		 *	@return Array		 */		public function get slideArray():Array {			return imagesArray;		}		/**		* @private		*/		public function set slideArray(newImageArray:Array):void {			imagesArray = newImageArray;		}		/**		 *	Get / Set if the slides use a timer to progress through the slideShow. If you set this value to <code>false</code> you must either use the <code>displayNewSlide()</code> method or		 *	dispatch a <code>LOAD_NEW_SLIDE</code> event at the Class.		 *	@default true		 *	@return Boolean		 */		public function get autoPlay():Boolean {			return autoSlides;		}		/**		* @private		*/		public function set autoPlay(newAutoSlides:Boolean):void {			autoSlides = newAutoSlides;		}		/**		 *	Get / Set if the slides loop when they reach the end of the possible images available to the class. If the slides are not set to loop, and you are in <code>randomPlayBack</code> mode		 *	the array of possible images is decremented with each new slide. This stops duplicate displaying of slides.		 *	@default true		 *	@return Boolean		 *	@see #randomPlayBack		 */		public function get slidesLoop():Boolean {			return looping;		}		/**		* @private		*/		public function set slidesLoop(newLooping:Boolean):void {			looping = newLooping;		}		/**		 *	Get / Set if the slides playback randomly, or in a linear fashion. In random mode and if the slides are not se to loop this property will cause the array of available images to be decremented with		 *	each new slide load. So that over time, the amount of available images to display will reduce to 0.		 *	@default true		 *	@return Boolean		 *	@see #slidesLoop		 */		public function get randomPlayBack():Boolean {			return randomXshow;		}		/**		* @private		*/		public function set randomPlayBack(newRandomXshow:Boolean):void {			randomXshow = newRandomXshow;		}		/**		 *	Get the total Number of slides currently available to the slideShow.		 *	@return Number		 */		public function get totalSlides():int {			return imagesArray.length;		}		/**		 *	Get the currently displayed slide		 *	@return int		 */		public function get currentSlide():int {			return p+1;		}		/**		 *	Get / Set the amount of time in seconds that each slide is displayed for.		 *	@default 20		 *	@return int		 */		public function get slideDisplayTime():int {			return imageTime;		}		/**		* @private		*/		public function set slideDisplayTime(newImageTime:int):void {			imageTime = newImageTime;		}		/**		 *	Get whether or not the slides are currently in a paused state.		 *	@default false		 *	@return Boolean		 */		public function get pauseStatus():Boolean {			return slidesPaused;		}		/**		 *	Get / Set the amount of time in <code>seconds</code> that it takes for a new background content to cross fade into the previous image. Set this property before you add this class to the display list.		 *	Or alternatively, you can change it each time you load in a new background image. If you pass in a number like <code>.5</code> then the fade time will be calculated base off the stages current		 *	frame rate. So, if you have a framerate of 30, and pass in .5 as your fade time, the internal tweens will default to using frames as their unit of measure, and your tween will complete in 15 frames.		 *	@default 2		 *	@return Number		 */		public function get slideCrossFadeTime():Number {			return crossFadeTime;		}		/**		* @private		*/		public function set slideCrossFadeTime(newcrossFadeTime:Number):void {			crossFadeTime = newcrossFadeTime;		}		//--------------------------------------		// CONSTRUCTOR		//--------------------------------------		/**		 *	NpFbXShowEvent		 *	<p>Review the various properties for the class for controlling the playback of your slideShow.</p>		 *	<p>Call <code>addChild()</code> after you set any Class Properties.</p>		 *	<p>This Class uses the <code>noponies.display.NpFSObjectResize</code> Class to handle the resizing of each slide to browser dimensions.</p>		 *	@param imagesArray Array of image URLS to use as source material for the slideShow. 		 *	@see #imageFadeTime		 *	@see #imageDisplayTime		 *	@see #randomPlayBack		 *	@see #slidesLoop 		 *	@see #autoPlay		 *	@see #slideAlignX		 *	@see #slideAlignY		 *	@see noponies.display.NpFSObjectResize		 *	@see #pause()		 *	@see #play()		 *	@see #displayNewSlide() 		 *	@return 		 *		 *@example Flash CS3 Timeline Based Demo.		 * <listing version="3.0">		 *  import noponies.display.NpFbXShowEvent;		 *var myImagesArray:Array = ["image.jpg, "image2.jpg", "image3.png"]		 *var newBgSlideShow:NpFbXShowEvent = new NpFbXShowEvent(myImagesArray);		 *newBgSlideShow.imageFadeTime = 10		 *newBgSlideShow.imageDisplayTime = 10		 *newBgSlideShow.randomPlayBack = true		 *newBgSlideShow.slidesLoop = true 		 *newBgSlideShow.autoPlay = true		 *newBgSlideShow.slideAlignX=1 //align slide bottomRight		 *newBgSlideShow.slideAlignY=1 //align slide bottomRight		 *addChildAt(newBgSlideShow,0);		 * </listing>		 */		public function NpFullBrowserXShow(imagesArray:Array) {			//resize Class Instances			tempResize = new NpFSObjectResize();			contentHolderResize = new NpFSObjectResize();			//access our images array			this.imagesArray = imagesArray;			addEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);//get stage access		}		//--------------------------------------		//		// PUBLIC METHODS - THIS FUNCTIONALITY IS ALSO EXPOSED VIA THE CLASSES EVENTS		//		//--------------------------------------		/**		*  	This public method will initiate the loading and display of a new slide.		*	<p>You are able to pass in an index property here that will load a particular slide from within the contained array of slides. Boundary testing occurs		*	and if you attempt to request an image beyond the bounds of the array, then an error will be thrown.</p>		*	@param slideToLoad int 		*	@default -1		*	@return		*/		public function displayNewSlide(slideToLoad:int = -1):void {			if (slideToLoad < 0) {				loadBgImage();			} else {				if (slideToLoad > imagesArray.length -1) throw new Error("Image requested is out of the bounds of the array containing image urls");				p = slideToLoad;				loadBgImage(p);			}		}		/**		*   This public method will pause the slideShow if it is in <code>autoPlay</code> mode and it is currently playing.		*	@see #autoPlay		*	@return		*/		public function pause():void {			pauseSlides();		}		/**		*   This public method will play the slideShow if it is in <code>autoPlay</code> mode and it has been paused.		*	@see #autoPlay		*	@return		*/		public function play():void {			restartSlides();		}		/**		*   This public method will unload and dispose of this Class. This functionally equivalent to the Class recieving a REMOVED_FROM_STAGE event.		*	@return		*/		public function unloadBg():void {			unloadAll();		}		//--------------------------------------		// LOAD IMAGE METHOD - LOADS IN NEW SLIDE ASSETS		//--------------------------------------		//will attempt to kill any currently downloading images if a new image is requested before the currently downloading image has finished loading.		private function loadBgImage(...args):void {			//if an image is currently downloading, and another image is requested, kill the loader and its download.			if (loader != null) {				try {					loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, loaded);					loader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR, onIOErrorHandler);					loader.contentLoaderInfo.removeEventListener(ProgressEvent.PROGRESS, progressHandler);					loader.close();					loader = null;				} catch (e:Error) {					trace(e);				}			}			loader = new Loader();			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);			loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onIOErrorHandler);			loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, progressHandler);			if (args.length == 0) {				loader.load(new URLRequest(String(imagesArray[p])));			} else {				loader.load(new URLRequest(String(imagesArray[args[0]])));			}		}		//--------------------------------------		// HANDLE A SUCCESSFUL LOAD OF AN IMAGE		//--------------------------------------		private function loaded(event:Event):void {			//dispatch the settings event			dispatchEvent(new Event(NpFbXShowEvent.SLIDE_CHANGE,true));			//check to see what slide mode we are in. If we are in automatic, reset the timer for the next cycle			if (autoSlides) {				slideTimer.reset();//reset the timer			}			//create the slide holder sprite			slide = new Sprite();			slide.alpha = 0;//set the slide content to have an alpha of 0			slide.x = slide.y = 0;			//bool to track what loader cycle we are in, so we can swap between bitmap vars.			loaderSwap = ! loaderSwap;			if (loaderSwap) {				bitDat1 = Bitmap(event.target.content).bitmapData;				bitMapBg = new Bitmap(bitDat1);			} else {				bitDat2 = Bitmap(event.target.content).bitmapData;				bitMapBg = new Bitmap(bitDat2);			}			//unload the loader			loader.unload();			//attach and smooth our bitmap object			bitMapBg.smoothing = true;			slide.addChild(bitMapBg);			addChild(slide);			//remove the eventListeners on the loader object and set it to null			loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, loaded);			loader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR, onIOErrorHandler);			loader.contentLoaderInfo.removeEventListener(ProgressEvent.PROGRESS, progressHandler);			loader = null;			//set initial scale of image			tempResize.addResizeTarget(slide,xPos,yPos);			//alpha in the content			//turn on this var, this is a flag that lets the temp resize function run			tweeningAlpha = true;			inTween = new Tween(slide,"alpha",None.easeIn,0,1,crossFadeTime,useSeconds);			inTween.addEventListener(TweenEvent.MOTION_FINISH, alphaTweenDone);			//reset the p counter variable based on if we have a random or linear slide show, and also check to see that the			//value is not beyond the total number of images we actually have in our array.			if (! looping && randomXshow) {				if (imagesArray.length == 0) {					pauseSlides();				} else {					imagesArray.splice(p,1);				}			}			if (! randomXshow) {				p++;			} else {				getUniqueNum();			}			if (! randomXshow && p == imagesArray.length && looping) {				p = 0;			}			if (! randomXshow && p == imagesArray.length && ! looping) {				pauseSlides();			}		}		//--------------------------------------		//		//  EVENT HANDLERS		//		//--------------------------------------		//--------------------------------------		//  FADE IN ALPHA TWEEN COMPLETE LISTENER		//--------------------------------------		private function alphaTweenDone(event:TweenEvent):void {			inTween.removeEventListener(TweenEvent.MOTION_FINISH, alphaTweenDone);			tweeningAlpha = false;//turn off the tweening variable			tempResize.removeResizeTarget();			contentHolderResize.addResizeTarget(slide,xPos,yPos);			//check here to see if we have a two slides existing, delete it if we do			if (this.numChildren > 1) {				//memory management !Attempt to keep memory useage down				//Here we check our loaderswap var, which we want to run opposite to what its current value is				//(so we can access the last bitmap), then we dispose of the old bitmap, which frees up memory immediately.				//We then run the child removal and the set to null routine for the garbage collector.				if (! loaderSwap) {					try {						bitDat1.dispose();					} catch (e:Error) {						trace(e);// 					}				} else {					try {						bitDat2.dispose();					} catch (e:Error) {						trace(e);// catch errors					}				}				//access the lowest (oldest) child of the Class Instance, and try to remove it				try {					bitMapBg = null;					removeChildAt(0);					slide = null;				} catch (e:Error) {					trace(e);//catch errors				}			}			if (autoSlides && ! slidesPaused) {				//restart the timer once the image has been loaded and displayed				if (! looping && p == imagesArray.length) {					slideTimer.reset();				} else {					slideTimer.start();//start the timer again when we have loaded in the slide				}			}			//dispatch the loaded event			dispatchEvent(new Event(NpFbXShowEvent.BG_LOADED,true));		}		//--------------------------------------		// LISTENER FOR THE NpFbXShowEvent.LOAD_NEW_SLIDE EVENT		//--------------------------------------		private function loadNewSlide(event:NpFbXShowEvent):void {			loadBgImage();		}		//--------------------------------------		// LISTENER FOR THE SLIDE TIMER EVENTS		//--------------------------------------		private function slideTime(event:TimerEvent):void {			loadBgImage();		}		//--------------------------------------		// ADDED TO STAGE LISTENER		//--------------------------------------		private function addedToStageHandler(event:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);									//add listeners			stage.addEventListener(NpFbXShowEvent.UNLOAD_BG, unloadAll);//listener for unload all event			stage.addEventListener(NpFbXShowEvent.PAUSE, pauseSlides);//listener for pausing slideshow			stage.addEventListener(NpFbXShowEvent.PLAY, restartSlides);//listener for restarting slideshows			stage.addEventListener(NpFbXShowEvent.LOAD_NEW_SLIDE, loadNewSlide);//listener for restarting slideshows			//set stage scale modes			addEventListener(Event.REMOVED_FROM_STAGE, unloadAll);			stage.scaleMode = StageScaleMode.NO_SCALE;			stage.align = StageAlign.TOP_LEFT;			//initial slide start position value			if (randomXshow) {				p = Math.floor((Math.random()*imagesArray.length));			} else {				p = 0;			}			//create timers			slideTimer = new Timer(imageTime * 1000,1);//timer			if (crossFadeTime < 1) {				useSeconds = false;				crossFadeTime = stage.frameRate * crossFadeTime;			}			//timer listener			if (autoSlides) {				slideTimer.addEventListener(TimerEvent.TIMER_COMPLETE, slideTime);			}			//load the bg image when we have stage access			loadBgImage();		}		//--------------------------------------		// HANDLE IO ERRORS		//--------------------------------------		private function onIOErrorHandler(event:IOErrorEvent):void {			trace("Shit, looks like there has been an ioError: " + event.text);		}		//--------------------------------------		// HANLE PROGRESS EVENTS FROM SLIDE LOAD OPERATIONS		//--------------------------------------		//progress handler, dispatches an event that can be used to monitor progress outside of this class		private function progressHandler(event:ProgressEvent):void {			//dispatch the loading event			dispatchEvent(new ProgressEvent(ProgressEvent.PROGRESS,false,true,event.bytesLoaded, event.bytesTotal));		}		//--------------------------------------		// LISTENER FOR THE NpFbXShowEvent.PAUSE EVENT		//--------------------------------------		private function pauseSlides(event:Event = null):void {			if (! slidesPaused) {				slideTimer.reset();				slidesPaused = true;			}		}		//--------------------------------------		// LISTENER FOR THE NpFbXShowEvent.PLAY EVENT		//--------------------------------------		private function restartSlides(event:Event = null):void {			if (slidesPaused) {				slideTimer.start();				slidesPaused = false;			}		}		//--------------------------------------		// LISTENER FOR THE REMOVED FROM STAGE EVENT OR THE UNLOAD_BG EVENT		//--------------------------------------		//dispatch an unload event to remove all listeners and set content to null		private function unloadAll(event:Event = null):void {			try {				removeEventListener(Event.REMOVED_FROM_STAGE, unloadAll);				stage.removeEventListener(NpFbXShowEvent.LOAD_NEW_SLIDE, loadNewSlide);				stage.removeEventListener(NpFbXShowEvent.PAUSE, pauseSlides);				stage.removeEventListener(NpFbXShowEvent.PLAY, restartSlides);				stage.removeEventListener(NpFbXShowEvent.UNLOAD_BG, unloadAll);				if (loaderSwap) {					bitDat1.dispose();					bitDat1 = null;					bitDat2 = null;				} else {					bitDat2.dispose();					bitDat1 = null;					bitDat2 = null;				}				if (inTween != null) {					if (inTween.isPlaying) {						inTween.stop(),						inTween.removeEventListener(TweenEvent.MOTION_FINISH,alphaTweenDone);					}				}				bitMapBg = null;				//kill the timers				slideTimer.stop();				slideTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, slideTime);				slideTimer = null;				tempResize.removeResizeTarget();				tempResize = null;			} catch (e:Error) {				trace("There was an error when attempting to delete all fullbrowser x fade content: "+Error);			}		}		//--------------------------------------		// CREATE A UNIQUE NUMBER FROM OUR IMAGE ARRAY		//--------------------------------------		private function getUniqueNum():void {			var tempRandomImg:int = Math.floor(Math.random() * imagesArray.length);			if (tempRandomImg == p && imagesArray.length > 1) {				getUniqueNum();			} else {				p = tempRandomImg;			}		}	}}