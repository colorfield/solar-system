package org.sse.solarsystem{		import org.sse.constant.PrivateParams;	import org.sse.model.CoordinateVO;	import org.sse.model.SolarSystemData;		import be.colorfield.ui.Application;	import be.colorfield.ui.layout.MainGUI;	import be.colorfield.net.LoaderXML;	import be.colorfield.events.ButtonEvent;	import be.colorfield.ui.control.MainButton;	import be.colorfield.utils.GenericTweener;		import com.google.maps.LatLng;	import com.google.maps.Map;	import com.google.maps.MapEvent;	import com.google.maps.MapMouseEvent;	import com.google.maps.MapOptions;	import com.google.maps.MapType;	import com.google.maps.controls.ControlPosition;	import com.google.maps.controls.MapTypeControl;	import com.google.maps.controls.ZoomControl;	import com.google.maps.extras.planetary.Mars;	import com.google.maps.extras.planetary.Moon;	import com.google.maps.extras.planetary.Sky;	import com.google.maps.styles.FillStyle;		import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.filters.DropShadowFilter;	import flash.filters.GlowFilter;	import flash.geom.Point;		import away3d.containers.View3D;	import away3d.core.utils.Cast;	import away3d.events.MouseEvent3D;	import away3d.lights.PointLight3D;	import away3d.materials.BitmapMaterial;	import away3d.materials.WhiteShadingBitmapMaterial;	import away3d.primitives.Cube;	import away3d.primitives.Sphere;			import mx.core.BitmapAsset;		//import org.bytearray.evenements.ButtonEvent;	//import org.bytearray.ui.MainButton;	//import org.bytearray.xml.LoaderXML;		// [SWF(width="800", height="600")]	public class GoogleMap extends Sprite	{				//------------------------------------------------------------------------		// MAPS		//------------------------------------------------------------------------				// énumération des types de cartes souhaitées pour cette application		public static const MAP_SKY:int =	 0;		public static const MAP_EARTH:int =	 1;		public static const MAP_MOON:int =	 2;		public static const MAP_MARS:int =	 3;				private var mapType:int;		private var map:Map;				// private static const LOCAL_PATH_TEXTURES:String = "../../../assets/images/textures/sphere/";		//------------------------------------------------------------------------		//  SUB MENU		//------------------------------------------------------------------------				private static const PADDING_BTN_Y:int = 5;		private static const COLOR_BTN:int = 0x1395EB;				private var conteneurMenu:Sprite;		private var menuBtn:Array;				//------------------------------------------------------------------------		//	PLANETS AWAY3D		//------------------------------------------------------------------------				[Embed(source="../../../assets/images/textures/sphere/earthmap1k.jpg")]		private var TextureEarth:Class;		private var mEarth:BitmapMaterial = new BitmapMaterial(Cast.bitmap(TextureEarth));				[Embed(source="../../../assets/images/textures/sphere/mars_1k_color.jpg")]		private var TextureMars:Class;		private var mMars:BitmapMaterial = new BitmapMaterial(Cast.bitmap(TextureMars));				[Embed(source = "../../../assets/images/textures/sphere/moon-125x63.jpg")]		private var TextureMoon:Class;		private var mMoon:BitmapMaterial = new BitmapMaterial(Cast.bitmap(TextureMoon));						private static const ROTATION_SPEED:Number = 0.2;				private var view:View3D;		private var sphere:Sphere;				private var curPositionVector:Vector.<CoordinateVO>;		private var curPosition:int;						//------------------------------------------------------------------------		//	CONSTRUCTEUR		//------------------------------------------------------------------------				// définition de la carte par défaut = autre manière de définir un deuxième constructeur		public function GoogleMap(mapType:int = GoogleMap.MAP_SKY)		{						addEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);						// si resize la Stage > la Map aussi			Application.MAIN_STAGE.addEventListener(Event.RESIZE,onResize);						this.mapType = mapType;							// position initiale dans le vecteur latitude/longitude			curPosition = 0;						// filtres			var atmosphereFilters:Array = new Array()						// sphere			sphere = new Sphere();			sphere.segmentsW = 32;			sphere.segmentsH = 32;			// sphere.material = mat;			// si on souhaite que le material soit illuminé			// sphere.material = new WhiteShadingBitmapMaterial(bmp);						sphere.x = 300;							// définir le vecteur souhaité et le material			switch(this.mapType){				case MAP_EARTH:					curPositionVector = SolarSystemData.getInstance().getEarthCoordinate();					atmosphereFilters.push(new GlowFilter(0xFFFFFF, 0.4, 15, 15, 2, 1, false, false));					sphere.material = mEarth;					break;				case MAP_MOON:					curPositionVector = SolarSystemData.getInstance().getMoonCoordinate();					sphere.material = mMoon;					atmosphereFilters.push(new GlowFilter(0xFFFFFF, 0.4, 15, 15, 2, 1, false, false));					break;				case MAP_MARS:					curPositionVector = SolarSystemData.getInstance().getMarsCoordinate();					sphere.material = mMars;					atmosphereFilters.push(new GlowFilter(0xFFFFFF, 0.4, 15, 15, 2, 1, false, false));					break;				case MAP_SKY:					curPositionVector = SolarSystemData.getInstance().getHubbleCoordinate();					sphere.material = mEarth;					atmosphereFilters.push(new GlowFilter(0xFFFFFF, 0.4, 15, 15, 2, 1, false, false));					break;			}						//-------------------------						map = new Map();			map.key = PrivateParams.API_KEY_GOOGLE_MAPS;			map.setSize(new Point(Application.MAIN_STAGE.stageWidth, Application.MAIN_STAGE.stageHeight));			//map.setSize(new Point(stage.stageWidth, stage.stageHeight));			map.sensor = "true";			map.addEventListener(MapEvent.MAP_READY, onMapReady, false, 0, true);			map.addEventListener(MapEvent.MAP_PREINITIALIZE,onMapPreinitialize, false, 0, true);						this.addChild(map as DisplayObject);						//-------------------------						view = new View3D();						// positionnement du point de fuite au centre			view.x = Application.MAIN_STAGE.stageWidth -= 400;			view.y = Application.MAIN_STAGE.stageHeight -= 200;			addChild(view);						// material			/*			var bmp:BitmapData = new BitmapData(200,200);			bmp.perlinNoise(200,200,2,Math.random(),true,true);						var mat:BitmapMaterial = new BitmapMaterial(bmp);			*/			// -------------------			// -------------------									// lumière			var light:PointLight3D = new PointLight3D();			light.y = 150;			view.scene.addLight(light);						sphere.ownCanvas=true;			sphere.filters = atmosphereFilters;						view.scene.addChild(sphere);						buildPlanetMenu();						// écoute du clic sur la sphère			sphere.addEventListener(MouseEvent3D.MOUSE_UP, onClickSphere);						// rendu à chaque frame			addEventListener(Event.ENTER_FRAME, onEnterFrame);					}				private function onResize(e:Event){			//trace("Resize");			map.setSize(new Point(Application.MAIN_STAGE.stageWidth, Application.MAIN_STAGE.stageHeight));			}						//------------------------------- TODO begin		private function buildPlanetMenu():void{						conteneurMenu = new Sprite();			conteneurMenu.x = Application.MAIN_STAGE.stageWidth - 200;			conteneurMenu.y = Application.MAIN_STAGE.stageHeight - 500;			this.addChild(conteneurMenu);						/*			planetMenuData = new Array();			for(var p:int = 0; p < curPositionVector.length; ++p){				planetMenuData.push( { legende : curPositionVector[p].label, vitesse : 1, lnk : "", couleur : 0xff6600 } );			}			*/						// nombre de rubriques			var monMainButton:MainButton;			var positionY:int = 0;			var legende:String;			var couleur:uint;			var vitesse:Number;			var lnk:int;						menuBtn = new Array();						for (var i:int = 0; i< curPositionVector.length; i++)			{				// création des MainButtons				monMainButton = new MainButton(i,COLOR_BTN,2,curPositionVector[i].label);								menuBtn.push(monMainButton);								// positionnement				monMainButton.y = positionY;								monMainButton.filters = [new DropShadowFilter()];								// ajout au sein du conteneur				conteneurMenu.addChild(monMainButton);				// accumule le décalage nécessaire				positionY += monMainButton.height + PADDING_BTN_Y;			}						// écoute de l'événement personnalisé au niveau du parent			conteneurMenu.addEventListener(ButtonEvent.CLICK, clicMainButton, true);					}								private function clicMainButton(e:ButtonEvent)		{			// lien passé dans l'événement personnalisé			var curLat:Number = curPositionVector[e.lnk].latitude;			var curLng:Number = curPositionVector[e.lnk].longitude;						map.setCenter(new LatLng(curLat,curLng));		}						//------------------------------- TODO end						private function onRemovedFromStage(e:Event):void{						//trace("Google Map RemovedFromStage");						map.removeEventListener(MapEvent.MAP_READY, onMapReady);			map.removeEventListener(MapEvent.MAP_PREINITIALIZE,onMapPreinitialize);					}						//------------------------------------------------------------------------		// 		MAP		//------------------------------------------------------------------------				/**		 * Définition des options en fonction du type de Map souhaitée		 */		private function onMapPreinitialize(event:Event):void {						var opts:MapOptions = new MapOptions();						switch(this.mapType){				//---------- API "documentée"				case MAP_EARTH:					opts.zoom = 10;					opts.mapType = MapType.SATELLITE_MAP_TYPE;					break;				//---------- API "non documentée"				case MAP_MOON:					opts.mapTypes = [Moon.ELEVATION_MAP_TYPE, Moon.VISIBLE_MAP_TYPE];					opts.mapType = Moon.VISIBLE_MAP_TYPE;					opts.zoom = 6;					break;								case MAP_MARS:					opts.mapTypes = [Mars.ELEVATION_MAP_TYPE, Mars.VISIBLE_MAP_TYPE, Mars.INFRARED_MAP_TYPE]; 					opts.mapType = Mars.VISIBLE_MAP_TYPE;					opts.zoom = 6;					break;								// Hubble Deep Space Field				case MAP_SKY:				default:					opts.mapTypes = [Sky.VISIBLE_MAP_TYPE];					opts.zoom = 7;					opts.backgroundFillStyle = new FillStyle();					opts.backgroundFillStyle.color = 0x000000;							break;			}						opts.center = new LatLng(curPositionVector[0].latitude,curPositionVector[0].longitude);			// TODO : highlight du MainButton courant			this.map.setInitOptions(opts);		}				private function onMapReady(event:Event):void {						var bottomRight:ControlPosition = new ControlPosition(ControlPosition.ANCHOR_BOTTOM_RIGHT, 16, 10);			this.map.addControl(new ZoomControl());						var typeControl:MapTypeControl = new MapTypeControl();			typeControl.setControlPosition(bottomRight);  			map.addControl(typeControl);		}						private function onEnterFrame(e:Event):void		{			sphere.rotationY += ROTATION_SPEED;			view.render();		}					private function onClickSphere(e:MouseEvent3D):void		{						// parcours circulaire du tableau			if(curPosition == curPositionVector.length){				curPosition = 0;				// TODO : enable du MainButton correspondant			}else{				++curPosition;			}						var curLat:Number = curPositionVector[curPosition].latitude;			var curLng:Number = curPositionVector[curPosition].longitude;						map.setCenter(new LatLng(curLat,curLng));							}									}}