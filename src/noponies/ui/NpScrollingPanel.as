/* AS3*Copyright 2008 noponies || Dale Sattler*/package noponies.scrollingpanel.ui{	import fl.transitions.Tween;	import fl.transitions.TweenEvent;	import fl.transitions.easing.Strong;		import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.*;	import flash.filters.BlurFilter;	import flash.geom.Rectangle;	import flash.utils.Timer;		import flash.utils.Dictionary;		import noponies.scrollingpanel.display.NpScrollingPanelItem;	import noponies.scrollingpanel.display.INpPanelItem;	import noponies.scrollingpanel.events.NpScrollingPanelEvent;		/**	*	<p>The NpScrollingPanel Class is designed to create a scrolling pane of content. The Class itself does not handle any loading in of content. You must	*	provide the class with DisplayObjects for it to scroll.</p>	*	<p>The Class supports scrolling in response to mouse movement over the panel, or via a public method.</p>	*	<p>It also suppors creating rows or columns of content and scrolling that. The Class also supports scaling its mask to browsers dimensions	*	or you can simply set it to a fixed size. You are also able to remove individual content items and the class will update the position	*	of the content items to accomodate items being removed.</p>	*	<p>Each content item is wrapped in a NpScrollingPanelItem Instance, which dispatches various custom mouse events. You can use these events to	*	track what content item has been clicked etc. Useful for using this class as part of a gallery etc.</p>	*	<p>You are able to drag to rearrange content items within the scrolling panel class.</p>	* 	<br /><br />	*	<b>Author:</b> noponies - <a href="http://www.blog.noponies.com/" target="_blank">www.blog.noponies.com</a><br />	* 	<b>Class version:</b> 1.2<br />	* 	<b>Actionscript version:</b> 3.0 Player Version 9.0.28<br />	* 	<b>Copyright:</b>	*	2009 Noponies - Dale Sattler	* 	<b>Date:</b> 20 Feb 2009<br />	* 	<b>Terms of use:</b> <a href="http://www.blog.noponies.com/terms-and-conditions" target="_blank">http://www.blog.noponies.com/terms-and-conditions</a>	*/		public class NpScrollingPanel extends Sprite {		//--------------------------------------		// PRIVATE INSTANCE PROPERTIES		//--------------------------------------		private var _maskWidth:int;		private var _maskHeight:int;		private var _counter:int;		private var _padding:int = 10;		private var _thumbY_pos:int		private var _thumbX_pos:int		private var _thumbMask:Sprite;		private var _thumbsHolder:Sprite;		private var _thumbsHolderBg:Sprite;		private var _itemArray:Array		private var _hitRect:Rectangle		private var _drawBg:Boolean = true		private var _bgColour:uint = 0xFFFFFF		private var _bgAlpha:Number = 1		private var _blurScroll:Boolean = false		private var _blurQual:int = 3		//scroller variables		private var _useMouseScroll:Boolean = true;		private var _useEndScroll:Boolean = false					//End scroll		private var _endScrollMaxSpeed:int = 40						//End scroll		private var _endScrollMargin:Number = .125					//End scroll		private var _scrollSpeed:int = 20				private var _pos:Number = 0;		private var _panelDirection:String = "horizontal";		private var _useStageDim:Boolean = true;		private var _mPos:int;		private var _targPos:Number;		private var _scrollingEnabled:Boolean;		private var _mX:int;		private var _mY:int;		private var _cachePanelAsBit:Boolean = true;		private var _blurAmount:Number = .4;		private var _panelReflect:Boolean = false;		private var _clipHalf:Number;		private var _myTween:Tween;//stop tweens getting grabage collected		private var _myThumbTween:Tween;				private var _changeVal:Number = 0;		private var _oldVal:Number = 0;		//timer that handles blurring the panel items		private var _blurTimer:Timer = new Timer(30);		private var _oldPos:int = 0;		//dict		private var _panelObjects:Dictionary		//vars to control dragging of items		private var _canDragItems:Boolean = false;		private var _isDragging:Boolean = false;		private var _draggedClip:INpPanelItem;		private var _dragTimer:Timer;		private var _dragDelayTime:Number = 500;		private var _dragOffSet:int				//--------------------------------------		// GETTERS / SETTERS		//--------------------------------------		/**		 *	Get / Set if the thumbnails have a reflection. The reflection is always at the bottom of your scrolling content. This means, that this works better for content scrolling		 * 	in the <code>x</code> direction.		 *	<p>If you are scrolling in the x direction, then you need to increase your panels mask height by 25% of the height of your content min. If you are scrolling in the y direction, then you must increase the _padding between		 *	each content item.</p>		 *	<p><em>This is a Class Instantiation Property.</em></p>		 *	<p><em>Enabling this and panel blurring with decrease performance.</em></p>		 *	@default false		 *	@see #panelMaskHeight		 *	@see #contentPadding		 *	@return Boolean		 */		public function get panelReflection():Boolean {			return _panelReflect;		}		/**		* @private		*/		public function set panelReflection(newBgReflect:Boolean):void {			_panelReflect = newBgReflect;		}						/**		 *	Get / Set the colour of the scrolling panel.		 *	<p><em>This is a Class Instantiation Property.</em></p>		 *	@default 0xFFFFFF (White)		 *	@return uint		 *	@see panelBgAlpha		 */		public function get panelBgColour():uint {			return _bgColour;		}		/**		* @private		*/		public function set panelBgColour(newBgCol:uint):void {			_bgColour = newBgCol;		}				/**		 *	Get / Set the alpha of the colour of the scrolling panels background.		 *	<p><em>This is a Class Instantiation Property.</em></p>		 *	@default 1 (solid)		 *	@return Number		 *	@see panelBgColour		 */		public function get panelBgAlpha():Number {			return _bgAlpha;		}		/**		* @private		*/		public function set panelBgAlpha(newBgAlpha:Number):void {			_bgAlpha = newBgAlpha;		}				/**		 *	Get / Set the spacing between each content item within the NpScrollingPanel.		 *	<p><em>This is a Class Instantiation Property. But you can use the <code>adjustPadding()</code> method to change padding at runtime!</em></p>		 *	@default 10		 *	@return int		 */		public function get contentPadding():int {			return _padding;		}		/**		* @private		*/		public function set contentPadding(newThumbPadding:int):void {			_padding = newThumbPadding;		}		/**		 *	Get / Set the <code>y</code> _position of each thumbnail in within the NpScrollingPanel. The pur_pose of this property is to enable you to		 *	create mulit rows of content within the NpScrollingPanel. 		 *	<p>To create a extra row of thumbnails within the NpScrollingPanel you would set both the <code>contentY_position</code> and the <code>contentX_position</code> 		 *	properties. For instance, if you are wanting to scroll content horizontally, with two rows after say the 10th element, you would reset the <code>contentX_position</code> to <code>0</code>		 *	as this property increments with each new thumbnail addition as well as changing the <code>contentY_position</code> to reflect the new <code>y</code> value of the next row of content.</p>		 *	<p><em>This is a Class Instantiation Property</em></p>		 *	@default 0		 *	@return int		 */		public function get contentY_position():int {			return _thumbY_pos;		}		/**		* @private		*/		public function set contentY_position(newThumbY_pos:int):void {			_thumbY_pos = newThumbY_pos;		}				/**		 *	Get / Set the <code>x</code> _position of each thumbnail in within the NpScrollingPanel. The pur_pose of this property is to enable you to		 *	create mulit columns of content within the NpScrollingPanel. 		 *	<p>To create a extra row of thumbnails within the NpScrollingPanel you would set both the <code>contentX_position</code> and the <code>contentY_position</code> 		 *	properties. For instance, if you are wanting to scroll content vertically, with two rows after say the 10th element, you would reset the <code>contentY_position</code> to <code>0</code>		 *	as this property increments with each new thumbnail addition as well as changing the <code>contentX_position</code> to reflect the new <code>x</code> value of the next column of content.</p>		 *	<p><em>This is a Class Instantiation Property</em></p>		 *	@default 0		 *	@return int		 */		public function get contentX_position():int {			return _thumbX_pos;		}		/**		* @private		*/		public function set contentX_position(newThumbX_pos:int):void {			_thumbX_pos = newThumbX_pos;		}						/**		 *	Get / Set the visible width of the thumbs track. This value is sets the width of the mask that that thumbs scroll behind. Has no effect if		 *	the <code>resizeThumbMaskToStage</code> property is enabled and you are scrolling content in the <code>horizontal</code> direction.		 *	@default 0		 *	@return int		 *	@see #resizePanelMaskToStage		 */		public function get panelMaskWidth():int {			return _maskWidth;		}		/**		* @private		*/		public function set panelMaskWidth(newMaskWidth:int):void {			_maskWidth = newMaskWidth;		}				/**		 *	Get / Set the visible height of the thumbs track. This value is sets the height of the mask that that thumbs scroll behind. Has no effect if		 *	the <code>resizePanelMaskToStage</code> property is enabled and you are scrolling content in the <code>vertical</code> direction.		 *	<p><em>You can set this property at runtime</em></p>		 *	@default 0		 *	@return int		 *	@see #resizePanelMaskToStage		 */		public function get panelMaskHeight():int {			return _maskHeight;		}		/**		* @private		*/		public function set panelMaskHeight(newMaskHeight:int):void {			_maskHeight = newMaskHeight;		}				/**		 *	Get / Set the whether or not the thumb track stretches to match either the stages width, or stages height, depending on what orientation the NpScrollingPanel happens to be in.		 *	<p><em>Make sure you set the op_posite track dimension value to the NpScrollingPanels orientation. So, if you are creating a horizontal thumb track, make sure you set the <code>panelMaskHeight</code> property.</em></p>		 *	<p><em>You can set this property at runtime.</em></p>		 *	@default 0 or stage.stageWidth		 *	@return Boolean		 */		public function get resizePanelMaskToStage():Boolean {			return _useStageDim;		}		/**		* @private		*/		public function set resizePanelMaskToStage(newUseStageDim:Boolean):void {			_useStageDim = newUseStageDim;		}				/**		 *	Get / Set whether or not the thumb scrolling is controlled by a user moving their mouse over the NpScrollingPanel.		 *	<p><em>You can set this property at runtime.</em></p>		 *	@default true		 *	@return Boolean		 */		public function get mouseScrolling():Boolean {			return _useMouseScroll;		}		/**		* @private		*/		public function set mouseScrolling(newUseMouseScroll:Boolean):void {			_useMouseScroll = newUseMouseScroll;		}				/**		 *	Get / Set the max speed the panel can scroll at. This property gives you access to the duration that the internal tweens run for. Each		 *	tween is set to run with the <code>useFrames</code> property set to true. So, larger numbers passed in here, result in slower tweens and thus		 *	slower scrolling as the tweens take longer to complete.		  *	<p><em>You can set this property at runtime.</em></p>		 *	@default 20		 *	@return int		 */		public function get scrollSpeed():int {			return _scrollSpeed;		}		/**		* @private		*/		public function set scrollSpeed(newSpeed:int):void {			_scrollSpeed = newSpeed;		}				/**		 *	Get / Set whether or not the thumb scrolling is controlled by a user moving their mouse over extreme left and right of the panel.		 *	<p><b>Note: You must also set the <code>mouseScrolling</code> property to true for this property to have any effect!</b></p>		 *	<p>You should also set the distance the edge of the panel is "active" for. By default this zone is .125% of the width of the panels		 *	mask.</p>		 *	<p>This value is calculated as a percentage of the users mouse _position inside the active zone verses either the right or the left of the panel. So, if		 *	a user has their mouse 99% to the left the panel, then the panel will scroll at 99% of the max speed set for the <code>panelEdgeScrollSpeed</code>.</p>		 *	@default false		 *	@return Boolean		 *	@see  panelEdgeScrollSpeed		 *	@see  panelEdgeScrollSpeed		 		 *	@see  mouseScrolling		 */		public function get panelEdgeScrolling():Boolean {			return _useEndScroll;		}		/**		* @private		*/		public function set panelEdgeScrolling(newUseMouseScroll:Boolean):void {			_useEndScroll = newUseMouseScroll;		}				/**		 *	Get / Set the max speed the panel can scroll at when in <code>panelEdgeScrolling</code> mode. Remember that, this is the max speed the panel can scroll at. The actual		 *	speed is a percentage of the <code>panelEdgeScrollMargin</code> property.		 *	@default 40		 *	@return int		 *	@see  panelEdgeScrolling		 *	@see  panelEdgeScrollMargin		  		 */		public function get panelEdgeScrollSpeed():int {			return _endScrollMaxSpeed;		}		/**		* @private		*/		public function set panelEdgeScrollSpeed(newEndScrollMaxSpeed:int):void {			_endScrollMaxSpeed = newEndScrollMaxSpeed;		}				/**		 *	Get / Set the size of the "active" area of the scrolling panel when you have enabled the <code>panelEdgeScrolling</code> property. 		 *	<p>This value is calculated as a percentage of the panels width or height. So, if you have panel width of 1000px and you set this property to .125, then the active		 *	area will be 125px at each edge of the panel.</p>		 *	@default .125		 *	@return Number		 *	@see  panelEdgeScrolling		 *	@see  panelEdgeScrollSpeed				 		 */		public function get panelEdgeScrollMargin():Number {			return _endScrollMargin;		}		/**		* @private		*/		public function set panelEdgeScrollMargin(newEndScrollMargin:Number):void {			_endScrollMargin = newEndScrollMargin;		}		/**		 *	Get / Set the _position of the thumbsTrack as a <code>percentage!</code> of the NpScrollingPanels mask (visible area) width. Valid value range is within the <code>0-1</code> range.		 *	<p>Use this property to scroll the thumbsTrack via external means, such as a slider bar or a mouse Click on a button</p>		 *	<p><em>You can set this property at runtime</em></p>		 *	@default 0		 *	@return Number		 */		public function get panelScrollPos():Number {			return _panelDirection == "horizontal" ? - _thumbsHolder.x / (_thumbsHolder.width - _thumbMask.width) : - _thumbsHolder.y / (_thumbsHolder.height - _thumbMask.height)		}		/**		* @private		*/		public function set panelScrollPos(newTrackPos:Number):void {			if(!_scrollingEnabled){				return			}			//test _thumbsHolder bounds against thumbMask, thumbsHolder must be larger than mask			if((_panelDirection == "horizontal" && _thumbsHolder.width <= _thumbMask.width)||(_panelDirection == "vertical" && _thumbsHolder.height <= _thumbMask.height)){				return			}			_panelDirection == "horizontal" ? doTween(-newTrackPos) : doTween(-newTrackPos) 		}				/**		 *	Get / Set the _position of the thumbsTrack as an int rather than as a percentage. Use this property if you want to _position the scrolling panel at an exact int value.		 *	<p>Use this property to scroll the thumbsTrack via external means, such as a slider bar or a mouse Click on a button</p>		 *	<p><em>You can set this property at runtime</em></p>		 *	@default 0		 *	@return int		 */		public function get panelScrollPosAsInt():int {			return _panelDirection == "horizontal" ? - _thumbsHolder.x : - _thumbsHolder.y 		}		/**		* @private		*/		public function set panelScrollPosAsInt(newTrackPos:int):void {			if(!_scrollingEnabled){				return			}			//test _thumbsHolder bounds against thumbMask, thumbsHolder must be larger than mask			if((_panelDirection=="horizontal" && _thumbsHolder.width<=_thumbMask.width)||(_panelDirection=="vertical" && _thumbsHolder.height<=_thumbMask.height)){				return			}			_panelDirection=="horizontal" ? doIntTween(-newTrackPos) : doIntTween(-newTrackPos) 		}				/**		 *	Get / Set if you want to blur the scrolled content as it scrolls. The amount of blur depends on how far the content has to scroll. Bigger distances		 * 	equate to bigger blurs. Content is blurred in the direction it is scrolling in.		 *	<p><strong>Blurring will swap to a slower process of iterating over each object in the scrolling panel if the content being scrolled exceeds either a height or width of 2880px.		 *	When you scroll content that is over this dimension, each individual item is blurred, rather than the panel as a whole. This is caused by a Flash limit of 2880px for bitmap objects.</strong></p>		 *	<p><em>Be aware that this will affect peformance</em></p>		 *	<p><em>You can set this property at runtime</em></p>		 *	@default false		 *	@return Boolean		 *	@see #panelBlurQuality		 */		public function get panelScrollBlur():Boolean {			return _blurScroll		}		/**		* @private		*/		public function set panelScrollBlur(newBlur:Boolean):void {			_blurScroll = newBlur		}				/**		 *	Get / Set the quality of the blur if you have enabled the <code>panelScrollBlur</code> property. Higher numbers set higher quality blurs but degrade performance!		 *	<p><em>Be aware that this high will affect peformance</em></p>		 *	<p><em>You can set this property at runtime</em></p>		 *	@default 3		 *	@return int		 *	@see panelScrollBlur		 */		public function get panelBlurQuality():int {			return _blurQual		}		/**		* @private		*/		public function set panelBlurQuality(newBlurQual:int):void {			_blurQual = newBlurQual		}				/**		 *	Get / Set the amount of the blurring if you have enabled the <code>panelScrollBlur</code> property. Higher numbers create greater amounts of blur!		 *	<p>Blurring is a proportion of the distance the panel has to travel. The effect of this property is to divide that amount to arrive at the level of blur.		 *	So, if you set a amount of <code>.5</code> then the blur will be calculated as .5 of that distance.</p>		 *	<p><em>You can set this property at runtime</em></p>		 *	@default .4		 *	@return Number		 *	@see panelScrollBlur		 */		public function get panelBlurAmount():Number {			return _blurAmount		}		/**		* @private		*/		public function set panelBlurAmount(newBlurAmount:Number):void {			_blurAmount = newBlurAmount		}				/**		 *	Get / Set whether or not to cache the scrolling content as a whole as a bitmap. This increases performance, but you will suffer a performance hit if your content		 *	visually changes etc. 		 *	<p>If you have enabled the <code>panelScrollBlur</code> property, the scrolling content will be bitmap cached when it is blurred, and returned to is previous cache state		 *	when the blur has finished.</p>		 *	<p><em>This property is tested each time the <code>enableScrolling</code> method is called.</em></p>		 *	@default true		 *	@return Boolean		 */		public function get renderPanelAsBitmap():Boolean {			return _cachePanelAsBit;		}		/**		* @private		*/		public function set renderPanelAsBitmap(newCachePanelAtBit:Boolean):void {			_cachePanelAsBit = newCachePanelAtBit;		}				/**		 *	Get width of the thumbs track. This is the width of the content that is scrolled.		 *	@default 0		 *	@return int		 */		public function get panelContentWidth():int {			return _thumbsHolder.width;		}				/**		 *	Get height of the thumbs track. This is the height of the content that is scrolled.		 *	@default 0		 *	@return int		 */		public function get panelContentHeight():int {			return _thumbsHolder.height;		}				/**		 *	Get / Set whether or not a user can drag panel items to change their order. With each new successful drag operation, each panel item will update its ID property		 *	to reflect its position within the panel.		 *	<p><em>You can set this property at runtime</em></p>		 *	@default false		 *	@return Boolean		 *	@see dragDelayTime		 */		public function get canDragPanelItems():Boolean {			return _canDragItems;		}		/**		* @private		*/		public function set canDragPanelItems(newDrag:Boolean):void {			_canDragItems = newDrag;			if(_dragTimer == null) {				_dragTimer = new Timer(_dragDelayTime, 1);				_dragTimer.addEventListener(TimerEvent.TIMER_COMPLETE, handleDragTimerComplete);			}		}				/**		 *	Get  an array containing the current panels content items. 		 *	@default false		 *	@return Array		 */		public function get panelContentItems():Array {			return _itemArray;		}			/**		 *	Set the time it takes between a user clicking on a panel content item, and the item becoming draggable. This property is designed to allow for drag operations		 *  in situations where the content item has other, interactivity such as buttons etc within it. The units of measure are milliseconds.		 *	@default 500 milliseconds		 *	@return Boolean		 *	@see canDragPanelItems		 */		public function set dragDelayTime(newDelay:Number):void {			_dragDelayTime = newDelay;		}				//--------------------------------------		// CONSTRUCTOR		//--------------------------------------		/**		*	The NpScrollingPanel Class Constructor takes one argument. A string representing the direction you want to scroll your content within.		*	<p>To add content to this scrollingPanel use the <code>addContentItem()</code> method. When you have finished adding in your content that you wish		*	to scroll, call the <code>enableScrolling()</code> method.</p>		*	<p>Set the <code>mouseScrolling, scrollEase, resizeThumbMaskToStage, panelEdgeScrolling, panelReflection,panelMaskWidth, panelBgColour, panelMaskHeight, contentPadding etc</code> properties before you call the <code>addContentItem()</code> method!</p>		*	<p>Use the <code>contentX_position</code> and <code>contentY_position</code> properties as you add content to the NpScrollingPanel class </em>if</em> you want to create multiple rows and columns</p>		*	<p>If you need to access individual contentItems, you can access their various dispatched events, and from those events, hook into the event.target property. You can also simply  query the 		*	<code>accessThumb()</code> method.</p>		*	@param String (Optional) Representing the direction you want to scroll in. The default scrolling direction is <code>horizontal</code>!.		*	@see #mouseScrolling		*	@see #resizeThumbMaskToStage		*	@see #panelMaskHeight		*	@see #panelMaskWidth		*	@see #contentPadding			*	@see #renderPanelAsBitmap		*	@see #panelEdgeScrolling		*	@see #panelReflection		*	@see #panelBgColour		*	@see #panelScrollBlur		*	@see enableScrolling()		*	@see #noponies.events.NpScrollingPanelEvent		*	@return		*	<br>		*	@example Example Useage		*   <listing version="3.0">		*	//Create a new instance of NpScrollingPanel Class and populate it with bitmaps from the library. This will scroll in a horizontal or x direction!		*		*	var thumbsContainer:NpScrollingPanel = new NpScrollingPanel();		*	thumbsContainer.resizePanelMaskToStage = true		*	thumbsContainer.panelMaskHeight = 200		*	addChild(thumbsContainer);		*		*	var libraryItem:Bitmap;		*		*	function createNewPanel():void {		*		for (var i:int = 0; i< 15; i++) {		*			var n:int=i%2;		*			if (n==0) {		*				var FireybreathData:Fireybreath = new Fireybreath(0, 0);		*				libraryItem = new Bitmap(FireybreathData);		*			} else {		*				var StrawberryData:Strawberry = new Strawberry(0, 0);		*				libraryItem = new Bitmap(StrawberryData);		*			}		*			thumbsContainer.addContentItem(libraryItem)		*			//when we have finished adding content, turn on scrolling		*			if(i==15){		*			thumbsContainer.enableScrolling()		*		}		*		}			*	}		*		*	createNewPanel()		*		*	</listing>		*/		public function NpScrollingPanel(_panelDirection:String = "horizontal") {			switch (_panelDirection.toLowerCase()) {				case "horizontal" :					this._panelDirection = _panelDirection.toLowerCase();					break;				case "vertical" :					this._panelDirection = _panelDirection.toLowerCase();					break;				default :				throw new Error("Problem :The direction parameter passed "+"\""+ _panelDirection+"\"" + " does not match the allowed orientation modes, which are: \"horizontal\", \"vertical\"");			};			_panelObjects = new Dictionary(true);			init();		}		//--------------------------------------	//	// PUBLIC METHODS	//	//--------------------------------------	//--------------------------------------	// ADD CONTENT ITEM	//--------------------------------------		/**	*   The <code>addContentItem()</code> public method adds DisplayObjects to the NpScrollingPanel. 	*	@param DisplayObject Representing the DisplayObject you want to add to the NpScrollingPanel	*	@see #contentPadding	*	@see #contentX_position	*	@see #contentY_position	*	@return	*/	public function addContentItem(thumbContent:DisplayObject):void {		//new instance of the PanelItem Class, if you wanted to use your own class, you would add in here		//it just needs to implement the INpPanelItem Interface		var newThumb:INpPanelItem = new NpScrollingPanelItem(thumbContent, _counter, _panelDirection, _panelReflect);		_thumbsHolder.addChild(DisplayObject(newThumb));		_panelObjects[thumbContent] =  newThumb;				if(_canDragItems) {			DisplayObject(newThumb).addEventListener(MouseEvent.MOUSE_DOWN, handleItemPress);			DisplayObject(newThumb).addEventListener(MouseEvent.MOUSE_UP, handleItemRelease);		}		if (_panelDirection=="horizontal") {			DisplayObject(newThumb).x = _thumbX_pos;			DisplayObject(newThumb).y = _thumbY_pos;		} else {			DisplayObject(newThumb).x = _thumbX_pos;			DisplayObject(newThumb).y = _thumbY_pos;		}				//create the mask		if (_counter==0) {			if (_useStageDim&&_panelDirection=="horizontal") {				_maskWidth = stage.stageWidth;							}			if (_useStageDim&&_panelDirection=="vertical") {				_maskHeight = stage.stageHeight;			}						//create the mask sprite for the thumbs track			_thumbMask = new Sprite();			_thumbMask.graphics.beginFill(0xFFFFFF);			_thumbMask.graphics.drawRect(0, 0, _maskWidth, _maskHeight);			_thumbMask.graphics.endFill();			_thumbMask.x = 0;			_thumbMask.y = 0;			addChild(_thumbMask);			this.mask = _thumbMask;						//set the bg of the thumbs track which is needed to create a smooth scrolling experience to match			//the heights and widths of the first instance of the loaded in content			//this sprite is resized again, as the content loads			_thumbsHolderBg.height = thumbContent.height;			_thumbsHolderBg.width = thumbContent.width;		}				//increment the _positional _counter for the thumbs _positions		if (_panelDirection=="horizontal") {			if(_panelReflect) {				_thumbsHolderBg.width = _thumbsHolder.width;				_thumbsHolderBg.height = _maskHeight-newThumb.thumbHeight;			}else{				_thumbsHolderBg.width = _thumbsHolder.width;				_thumbsHolderBg.height = _maskHeight;			}			_thumbX_pos+=thumbContent.width + _padding;		} else {			_thumbsHolderBg.height = _thumbsHolder.height;			_thumbsHolderBg.width = _maskWidth;			_thumbY_pos+=thumbContent.height + _padding;		}		//create the _counter		_counter++;		_itemArray.push(newThumb);			}			//--------------------------------------	// ENABLE SCROLLING	//--------------------------------------		/**	*   The <code>enableScrolling()</code> public method will enable both mouse movement (Depending on if you have enabled the <code>mouseScrolling</code> or the <code>panelEdgeScrolling</code> property) 	*	and setter based scrolling.	*	@see #mouseScrolling	*	@see #panelEdgeScrolling	*	@see #panelScrollPos	*	@see disableScrolling()	*	@return	*/	public function enableScrolling():void {				//enable mouse based scrolling, if it desired. Note the slight inflation of the rectangle. We need to offset it slightly as Flash tests			//for less than when running a rectangle.contains() method. 			if(_panelReflect) {				_panelDirection=="horizontal" ? _hitRect = new Rectangle(0, 0, _maskWidth+1, _maskHeight) : _hitRect = new Rectangle(0, 0, _maskWidth, _maskHeight+1);			}else{				_panelDirection=="horizontal" ? _hitRect = new Rectangle(0, 0, _maskWidth+1, _maskHeight) : _hitRect = new Rectangle(0, 0, _maskWidth, _maskHeight+1);			}			if (_useMouseScroll) {				addScrollListeners();			}		_scrollingEnabled = true;		//check to see if we are cacheing the content		_cachePanelAsBit ? _thumbsHolder.cacheAsBitmap = true : _thumbsHolder.cacheAsBitmap = false		 if(_blurScroll){			_blurTimer.addEventListener(TimerEvent.TIMER, handleBlur, false, 0, true);			_panelDirection == "horizontal" ?  _oldPos = _thumbsHolder.x : _oldPos = _thumbsHolder.y;			_blurTimer.start();		 }		 		 //add the stage resize listener if its required		if(_useStageDim){			stage.addEventListener(Event.RESIZE, resizeHandler);		}		}		//--------------------------------------	// DISABLE SCROLLING	//--------------------------------------	/**	*   The <code>disableScrolling()</code> public method will disable both mouse movement based and setter based scrolling.	*	<p>To enable scrolling again, call the <code>enableScrolling</code> method.</p>	*	@see enableScrolling()		*	@return	*/	public function disableScrolling():void {		if (this.willTrigger(Event.ENTER_FRAME)) {			this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);		}		_scrollingEnabled = false		if(_blurScroll){			_blurTimer.stop()		 }		}			//--------------------------------------	// ENABLE MOUSE SCROLLING	//--------------------------------------	/**	*   The <code>enableMouseScrolling()</code> public method enables mouseScrolling of the panel. This method is designed to be	*	used when the panel is set to not use mouseScrolling, and you for a short amount of time need to turn it on. An example of this is	*	dragging a panel item from a panel instance that is set to only use setter based scrolling (ie, scrolled by a scroll bar).	*	@see disableMouseScrolling()		*	@return	*/		public function enableMouseScrolling():void {			_useMouseScroll = true;		if(!_scrollingEnabled) {			enableScrolling();		}		//call the mouse scroll method, otherwise it waits for a rollover, which wont happen if we are dragging content		mouseScroll();	}		//--------------------------------------	// DISABLE MOUSE SCROLLING	//--------------------------------------	/**	*   The <code>disbleMouseScrolling()</code> public method disables mouseScrolling of the panel, but leaves setter scrolling enabled.	*	@see enableMouseScrolling()		*	@return	*/			public function disableMouseScrolling():void {			_useMouseScroll = false;		//check to see if we have an enterframe event running, kill it, if we do.		if (this.willTrigger(Event.ENTER_FRAME)) {			this.removeEventListener(Event.ENTER_FRAME,entFrameScroll);		}		removeScrollListeners();	}	//--------------------------------------	// REMOVE A PARTICULAR CONTENT ITEM	//--------------------------------------	/**	*   The <code>removeContentItem()</code> public method will remove a contentItem from the NpScrollingPanel. ContentItems with either a 	*	greater x or y (depending on scrolling direction) than the removed item will move their positions to fill the 'gap' left by deleting	*	the contentItem.	*	<p>!! Removing content items when you have multi row or column scrollable content will possibly cause errors</p>	*	<p>Pass in the ID of the thumbnail you want to delete. When thumbs are added to the thumbsTrack they are allocated an ID, which corresponds	*	to the order they are added in.</p>	*	@param int Representing the ID of the thumbnail you want to delete from the thumbsTrack.	*	@return	*/	public function removeContentItem(id:int):void {		if(id > _itemArray.length) return;		var thumbToDeleteDim:Number;				//remove item from dictionary		delete _panelObjects[_itemArray[id]];				//if we have enabled dragging, remove those listeners		if(_canDragItems) {			_itemArray[id].removeEventListener(MouseEvent.MOUSE_DOWN, handleItemPress);			_itemArray[id].removeEventListener(MouseEvent.MOUSE_UP, handleItemRelease);		}				_panelDirection == "horizontal" ? thumbToDeleteDim = _itemArray[id].thumbWidth : thumbToDeleteDim = _itemArray[id].thumbHeight;		_thumbsHolder.removeChild(_itemArray[id]);		_itemArray.splice(id,1);		//call the repositioning method, will shuffle clips to take up space left due to item removal		rePositionItems()			if(_drawBg){			_panelDirection=="horizontal" ? _thumbsHolderBg.width -= thumbToDeleteDim + _padding : _thumbsHolderBg.height -= thumbToDeleteDim + _padding		};		//adjust _pos of panel if we are at the far right/bottom of the scroll and we remove a clip		if(_panelDirection == "horizontal"){			if(_thumbsHolder.x + _thumbsHolder.width <= _hitRect.width) _thumbsHolder.x += thumbToDeleteDim + _padding;		}else{			if(_thumbsHolder.y + _thumbsHolder.height <= _hitRect.height) _thumbsHolder.y += thumbToDeleteDim + _padding;		}	}		//--------------------------------------	// ADJUST THUMB PADDING	//--------------------------------------	/**	*   The <code>adjustContentPadding()</code> public method will adjust the _padding between each content item at runtime. Calling this method will	*	result in the content items tweening in unison to their new positions.	*	@param int Representing the amount of padding you would like between each thumbnail.	*	@see enableScrolling()		*	@return	*/	public function adjustContentPadding(newPadding:int):void {		//set padding prop		_padding = newPadding;		//iterate through elements contained in our itemArray		var i:int = 0;			if(_panelDirection=="horizontal"){				for (i = 0; i < _itemArray.length; i++) {					_myThumbTween = new Tween(_itemArray[i], "x", Strong.easeOut, _itemArray[i].x, _itemArray[i].x + _padding * i, 1, true);				}			}else {				for (i = 0; i < _itemArray.length; i++) {					_myThumbTween = new Tween(_itemArray[i], "y", Strong.easeOut, _itemArray[i].y, (_itemArray[i].height + _padding) * i, 1, true);				}			}					if(_drawBg){			_panelDirection=="horizontal" ? _thumbsHolderBg.width += (_padding * _itemArray.length) - _padding : _thumbsHolderBg.height += (_padding * _itemArray.length) - _padding; 		}	}		//--------------------------------------	// UNLOAD ALL THUMBS	//--------------------------------------		/**	*   The <code>removeAllContentItems()</code> public method will unload any thumbnails currently loaded. It will also reset the heights and widths	*	of the NpScrollingPanel. Any mouse event listeners registered with the NpScrollingPanel will also be removed.	*	<p>You would use this method if you wanted to repopulate the class with a new set of content.</p>	*	@return	*/	public function removeAllContentItems():void {		//kill scrolling		_scrollingEnabled = false		//kill any bluring		if(_blurScroll){			_blurTimer.stop()		 }				//deal with listeners first				if (this.willTrigger(Event.ENTER_FRAME)) {			this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);		}		if (_useMouseScroll) {			this.removeEventListener(MouseEvent.ROLL_OVER, mouseScroll);		}				//clear thumbs		if (_thumbsHolder.numChildren >1) {			while (_thumbsHolder.numChildren >1) {				//if we have enabled dragging, lets remove the associated listeners				if(_canDragItems) {					_thumbsHolder.getChildAt(1).removeEventListener(MouseEvent.MOUSE_DOWN, handleItemPress);					_thumbsHolder.getChildAt(1).removeEventListener(MouseEvent.MOUSE_UP, handleItemRelease);				}								//remove item from dictionary				delete _panelObjects[_thumbsHolder.getChildAt(1)];				_thumbsHolder.removeChildAt(1);			}		}		//reset internal props		_counter=0;		if(_drawBg){			_thumbsHolderBg.width = _thumbsHolderBg.height = 0;		}		_thumbY_pos = 0		_thumbX_pos = 0		this.mask = null;		removeChild(_thumbMask);		_itemArray = []		}	//--------------------------------------	// REFERENCE A PARTICULAR THUMB	//--------------------------------------				/**	*   The <code>getContentItemById()</code> public method is a means of gaining access to a particular contentItem within the thumbsTrack.	*	<p>You would use this method if you wanted to manipulate individual contentItems. An obvious caveat with this method is that you need to know the	*	ID of the contentItem you wish to target. If you don't know this, use the <code>getContentItemId</code> method.</p>	*	@param int Representing the ID of the contentItem you wish to access. ContentItems are ordered by either their x or y values.	*	@return DisplayObject representing the thumbNail which has the passed in ID.	*/	public function getContentItemById(id:int):DisplayObject{		return(_itemArray[id])	}		/**	*   The <code>getContentItemId()</code> public method is a means of obtaining the ID of a particular contentItem. 	*	@param DisplayObject representing the content item you want to obtain an ID from.	*	@return int representing the ID of the passed in displayObject key reference.	*/	public function getContentItemId(target:DisplayObject):int {		return _panelObjects[target].thumbId;	}				//--------------------------------------	//	// PRIVATE METHODS	//	//--------------------------------------		//--------------------------------------	// INIT HANDLER - CALLED FROM CONSTRUCTOR	//--------------------------------------	//create thumbs holder sprite here, just do this once		private function init():void {		_itemArray = []		_thumbsHolder = new Sprite();		addChild(_thumbsHolder);		addEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);	}		//--------------------------------------	//	// FOLLOWING METHODS ALLOW FOR DRAGGING PANEL ITEMS	//	//--------------------------------------	//we use a timer to allow for interactive content items, as well as for allowing those items to be dragged	//the timer simply delays the time before a drag operation starts, which allows for normal clicks to function		//press on item	private function handleItemPress( event:MouseEvent ):void {		_dragTimer.start();		_draggedClip =  event.currentTarget as INpPanelItem;		_panelDirection == "horizontal" ? _dragOffSet = event.localX  : _dragOffSet = event.localY			}		private function handleItemRelease( event:MouseEvent ):void {		_dragTimer.stop();		if(_isDragging) {			_isDragging = false;			Sprite(_draggedClip).stopDrag();			_draggedClip = null;			//set items back into either vertical or horizontal position			if(_panelDirection=="horizontal"){				NpScrollingPanelItem(event.currentTarget).y = 0;			}else{				NpScrollingPanelItem(event.currentTarget).x = 0;			}			//shuffle position of items within panel			rePositionItems();		}	}		private function handleDragTimerComplete(event:TimerEvent):void {		_thumbsHolder.setChildIndex( Sprite(_draggedClip), _thumbsHolder.numChildren - 1 );		Sprite(_draggedClip).startDrag();		_isDragging = true;		dispatchEvent(new NpScrollingPanelEvent(NpScrollingPanelEvent.DRAG_START,true, true, _draggedClip.thumbId));	}		//this method moves each item within the panel, after a successful drag operation, simply uses array sorting	private function rePositionItems():void {		//copy array into temp array		var tempArray:Array = _itemArray.concat();				var i:int = 0;		if(_panelDirection=="horizontal"){			_itemArray.sortOn( 'x', Array.NUMERIC );			for (i = 0; i < _itemArray.length; i++) {				_myThumbTween = new Tween(_itemArray[i], "x", Strong.easeOut, _itemArray[i].x, (_itemArray[i].width + _padding) * i, 1, true);				_itemArray[i].thumbId = i;			}		}else {			_itemArray.sortOn( 'y', Array.NUMERIC );			for (i = 0; i < _itemArray.length; i++) {				_myThumbTween = new Tween(_itemArray[i], "y", Strong.easeOut, _itemArray[i].y, (_itemArray[i].height + _padding) * i, 1, true);				_itemArray[i].thumbId = i;			}		}				//compare the two arrays		var equivalent:Boolean = true;		for(i = 0; i < _itemArray.length; i++) {    		if(tempArray[i] != _itemArray[i]) {        		equivalent = false;        		break;    		}		}				if(!equivalent){			//dispatch the change event, indicating that content has changed, only if something has changed			dispatchEvent(new NpScrollingPanelEvent(NpScrollingPanelEvent.PANEL_CONTENT_CHANGE,true, false));		}	}		//--------------------------------------	// ADDED TO STAGE HANDLER	//--------------------------------------		private function addedToStageHandler(event:Event):void {		removeEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);		if(_drawBg){			_thumbsHolderBg = new Sprite();			_thumbsHolderBg.graphics.beginFill(_bgColour, _bgAlpha);			_thumbsHolderBg.graphics.drawRect(0, 0, 1, 1);			_thumbsHolderBg.graphics.endFill();			_thumbsHolder.addChildAt(_thumbsHolderBg,0);			_thumbsHolderBg.cacheAsBitmap = true		}		//add the stage resize listener if its required		if(_useStageDim){			stage.addEventListener(Event.RESIZE, resizeHandler);		}				addEventListener(Event.REMOVED_FROM_STAGE, handleRemovedFromStage)				//if we can drag items, add the drag timer		if(_canDragItems) {			_dragTimer = new Timer(_dragDelayTime, 1);			_dragTimer.addEventListener(TimerEvent.TIMER_COMPLETE, handleDragTimerComplete);		}	}		//--------------------------------------	// RESIZE HANDLER	//--------------------------------------		private function resizeHandler(event:Event):void {		if (_useStageDim) {			if (_panelDirection=="horizontal") {				if (_thumbsHolder.x+_thumbsHolder.width<stage.stageWidth) {					_thumbsHolder.x = stage.stageWidth-_thumbsHolder.width;				}				//test for when the stage is resized when the thumbs are loading				if(_thumbsHolder.width<=stage.stageWidth){					_thumbsHolder.x = 0				}				_thumbMask.width = stage.stageWidth;				_thumbMask.height = _maskHeight				_hitRect = new Rectangle(1, 0, _thumbMask.width-1, _maskHeight)			} else {				if (_thumbsHolder.y+_thumbsHolder.height<stage.stageHeight) {					_thumbsHolder.y = stage.stageHeight-_thumbsHolder.height;				}				//test for when the stage is resized when the thumbs are loading				if(_thumbsHolder.height<=stage.stageHeight){					_thumbsHolder.x = 0				}				_thumbMask.height = stage.stageHeight;				_thumbMask.width = _maskWidth				_hitRect = new Rectangle(1, 0, _maskWidth, _thumbMask.height-1)			}		}	}	//--------------------------------------	//	// MOUSESCROLLING FUNCTIONS	//	//--------------------------------------	//function that simply adds the event listeners to our scroll track	//we call this when we have loaded in all the thumbs, as this stops a user from being	//able to scroll a half empty thumbnails track, which would look crap.		private function addScrollListeners():void {		addEventListener(MouseEvent.ROLL_OVER, mouseScroll);	}		private function removeScrollListeners():void {		removeEventListener(MouseEvent.ROLL_OVER, mouseScroll);	}		//handlers that either add or delete the scroll enterframe event	private function mouseScroll(event:MouseEvent = null):void {		if(!_scrollingEnabled){				return			}		//test _thumbsHolder bounds against _thumbMask, _thumbsHolder must be larger than mask		if((_panelDirection=="horizontal" && _thumbsHolder.width<=_thumbMask.width)||(_panelDirection=="vertical" && _thumbsHolder.height<=_thumbMask.height)){				return			}					if(_blurScroll){			_panelDirection == "horizontal" ?  _oldPos = _thumbsHolder.x : _oldPos = _thumbsHolder.y			_blurTimer.start()		 }			//check to see if we have an enterframe event running, if not add it		if (! this.willTrigger(Event.ENTER_FRAME)) {			this.addEventListener(Event.ENTER_FRAME,entFrameScroll);		}	}		//--------------------------------------	// ENTERFRAME HANDLER	//--------------------------------------			private function entFrameScroll(event:Event):void{		//we have content to scroll, so lets scroll it!		_panelDirection=="horizontal" ? scrollThumbsX() : scrollThumbsY() 	}		//--------------------------------------	// TWEENING METHODS	//--------------------------------------	private function doTween(targetPos:Number):void{		_panelDirection == "horizontal" ?  _myTween = new Tween(_thumbsHolder, "x", Strong.easeOut, _thumbsHolder.x, int((_thumbsHolder.width-_thumbMask.width)*targetPos), _scrollSpeed, false)		:  _myTween = new Tween(_thumbsHolder, "y", Strong.easeOut, _thumbsHolder.y, int((_thumbsHolder.height-_thumbMask.height)*targetPos), _scrollSpeed, false);		_myTween.addEventListener(TweenEvent.MOTION_CHANGE, checkBounds)	}		//tweens to a particular integer, or pixel _position rather than a percentage	private function doIntTween(targetPos:int):void{		_panelDirection == "horizontal" ?  _myTween = new Tween(_thumbsHolder, "x", Strong.easeOut, _thumbsHolder.x, targetPos, _scrollSpeed, false)		:  _myTween = new Tween(_thumbsHolder, "y", Strong.easeOut, _thumbsHolder.y, targetPos, _scrollSpeed, false);		_myTween.addEventListener(TweenEvent.MOTION_CHANGE, checkBounds)	}		//--------------------------------------	// SCROLLING IN THE X DIRECTION	//--------------------------------------		private function scrollThumbsX():void {		//store the _position of the panel, with iteration of this method		//we use this to calculate how much distance we are moving		_oldVal = _thumbsHolder.x		if (_oldVal < 0)  _oldVal = -_oldVal;				//store mouse _pos as vars		_mX = mouseX;		_mY = mouseY;						if (!_hitRect.contains(_mX,_mY)) {			this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);			return;		}		//EDGE SCROLLING		if(_useEndScroll){			if (mouseX < _hitRect.width * _endScrollMargin) _myTween = new Tween(_thumbsHolder, "x", Strong.easeOut, _thumbsHolder.x, _thumbsHolder.x + _endScrollMaxSpeed*(1-(_mX/int(_hitRect.width * _endScrollMargin))), _scrollSpeed, false), 			_myTween.addEventListener(TweenEvent.MOTION_CHANGE, checkBounds, false, 0, true)			if (mouseX > _hitRect.width*(1 - _endScrollMargin)) _myTween = new Tween(_thumbsHolder, "x", Strong.easeOut, _thumbsHolder.x, _thumbsHolder.x - _endScrollMaxSpeed*(int(_mX-(_hitRect.width-1) * (1 - _endScrollMargin))/int(_hitRect.width-_hitRect.width*(1 - _endScrollMargin))), _scrollSpeed, false),			_myTween.addEventListener(TweenEvent.MOTION_CHANGE, checkBounds, false, 0, true)		}else{			//MOUSE MOVE SCROLLING			if (_mX < 0)  _mX = 0;			_mPos = _mX;			_targPos = -(_mPos/(_hitRect.width/(_thumbsHolder.width - _hitRect.width)))				_myTween = new Tween(_thumbsHolder, "x", Strong.easeOut, _thumbsHolder.x, _targPos, _scrollSpeed, false), 			_myTween.addEventListener(TweenEvent.MOTION_CHANGE, checkBounds, false, 0, true)		}		//dampening & kill event handler when we are belowing 1px movement increments		var n:int = quickAbs(_oldVal - _changeVal)				if(_isDragging){			DisplayObject(_draggedClip).x = _thumbsHolder.mouseX - _dragOffSet;		}		if (n < 1) {			if (!_useMouseScroll) this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);			if (!_hitRect.contains(_mX,_mY)) this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);		}	}		//--------------------------------------	// SCROLLING IN THE Y DIRECTION	//--------------------------------------			private function scrollThumbsY():void {		//store the _position of the panel, with iteration of this method		//we use this to calculate how much distance we are moving		_oldVal = _thumbsHolder.y		if (_oldVal < 0)  _oldVal = -_oldVal;				//store mouse _pos as vars		_mX = mouseX;		_mY = mouseY;				if (!_hitRect.contains(_mX,_mY)) {			this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);			return;		}		//EDGE SCROLLING		if(_useEndScroll){			if (mouseY < _hitRect.height * _endScrollMargin) _myTween = new Tween(_thumbsHolder, "y", Strong.easeOut, _thumbsHolder.y, _thumbsHolder.y + _endScrollMaxSpeed * (1-(_mY/int(_hitRect.height*_endScrollMargin))), _scrollSpeed, false), 			_myTween.addEventListener(TweenEvent.MOTION_CHANGE, checkBounds, false, 0, true);			if (mouseY > _hitRect.height*(1 - _endScrollMargin)) _myTween = new Tween(_thumbsHolder, "y", Strong.easeOut, _thumbsHolder.y, _thumbsHolder.y - _endScrollMaxSpeed * (int(_mY-(_hitRect.height-1)*(1 - _endScrollMargin))/int(_hitRect.height-_hitRect.height*(1 - _endScrollMargin))), _scrollSpeed, false), 			_myTween.addEventListener(TweenEvent.MOTION_CHANGE, checkBounds, false, 0, true);		}else{			//MOUSE MOVE SCROLLING			if (_mY < 0)  _mY = 0;			_mPos = _mY;			_targPos = -(_mPos/(_hitRect.height/(_thumbsHolder.height - _hitRect.height)));				_myTween = new Tween(_thumbsHolder, "y", Strong.easeOut, _thumbsHolder.y, _targPos, _scrollSpeed, false);			_myTween.addEventListener(TweenEvent.MOTION_CHANGE, checkBounds, false, 0, true);		}				if(_isDragging){			DisplayObject(_draggedClip).y = _thumbsHolder.mouseY - _dragOffSet;		}				//dampening & kill event handler when we are belowing 1px movement increments		var n:int = quickAbs(_oldVal - _changeVal)				if (n < 1) {			if (!_useMouseScroll) this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);			if (!_hitRect.contains(_mX,_mY)) this.removeEventListener(Event.ENTER_FRAME, entFrameScroll);		}	}	//--------------------------------------	// PANEL BLURRING METHODS - USES A TIMER WHICH IS LESS OF A CPU HIT TO RUN	//--------------------------------------		//test the width / height of the panel content. If its over 2880 px, we have to move to a slower 'iterate over each thumb and blur that'	//type blur rather than a quicker blur on the _thumbsHolder sprite itself		private function handleBlur(event:TimerEvent):void {		var newPos:int ;		var n:int;		_oldPos = quickAbs(_oldPos);		_panelDirection=="horizontal" ? newPos = quickAbs(_thumbsHolder.x) : newPos = quickAbs(_thumbsHolder.y) 		//dampen the blur amount		n = Math.min(quickAbs( _oldPos - newPos), 10);				if(_panelDirection=="horizontal"){			doBlurX(n);			_oldPos = _thumbsHolder.x;		}else{			doBlurY(n);			_oldPos = _thumbsHolder.y;		}		if(n==0)killBlur();	}	private function doBlurX(n:Number):void {		if(_thumbsHolder.width<2880){			_thumbsHolder.filters=[new BlurFilter(0, (n* _blurAmount), _blurQual)];		}else{			var len:int = _itemArray.length			for (var i:int = 0; i< len; i++) {				var p: Sprite = _itemArray[i];				p.filters=[new BlurFilter(0, (n * _blurAmount), _blurQual)];			}		}	}		private function doBlurY(n:Number):void {		if(_thumbsHolder.height<2880){			_thumbsHolder.filters=[new BlurFilter((n* _blurAmount),0 , _blurQual)];		}else{			var len:int = _itemArray.length			for (var i:int = 0; i< len; i++) {				var p: Sprite = _itemArray[i];				_thumbsHolder.filters=[new BlurFilter((n* _blurAmount),0 , _blurQual)];			}		}	}		private function killBlur():void {		if(_thumbsHolder.width<2880 || _thumbsHolder.height<2880){			_thumbsHolder.filters=[];		}else{			var len:int = _itemArray.length			for (var i:int = 0; i< len; i++) {				var s: Sprite = _itemArray[i];				s.filters=[];			}		}	}		//--------------------------------------	// CHECK SCROLL BOUNDS METHOD	//--------------------------------------			private function checkBounds(event:TweenEvent):void{		_changeVal = quickAbs(event.target.finish);				var n:int = quickAbs(_oldVal - _changeVal)		if(n == 0) {			_myTween.stop();			_myTween.removeEventListener(TweenEvent.MOTION_CHANGE, checkBounds, true);		}		if(_panelDirection == "horizontal") {			if(_thumbsHolder.x >= 0) {				_thumbsHolder.x = 0;			}						if(_thumbsHolder.x + _thumbsHolder.width <= _hitRect.width) {				_thumbsHolder.x = _hitRect.width - _thumbsHolder.width;			}			//scrolling in the y direction			}else{				if(_thumbsHolder.y >= 0) {				_thumbsHolder.y = 0;			}						if(_thumbsHolder.y + _thumbsHolder.height <= _hitRect.height) {				_thumbsHolder.y = _hitRect.height - _thumbsHolder.height;			}		}		//dispatch the CONTENT_SLIDING event		dispatchEvent(new NpScrollingPanelEvent(NpScrollingPanelEvent.SCROLLING,true, false, undefined, panelScrollPos));	}			//--------------------------------------	// UTIITY METHODS	//--------------------------------------			private function quickAbs(val:int):int{		if (val < 0)  val = -val;		return val;	}		//--------------------------------------	// HANDLE A REMOVED FROM STAGE EVENT	//--------------------------------------		//clean up the class when removed from stage	private function handleRemovedFromStage(event:Event):void {		try {			removeEventListener(Event.REMOVED_FROM_STAGE, handleRemovedFromStage)			if(_useStageDim){				stage.removeEventListener(Event.RESIZE, resizeHandler);			}					//call public removeAllContent Method			removeAllContentItems();						//kill timers			if(_canDragItems){				_dragTimer.stop();				_dragTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, handleDragTimerComplete);			}						if(_blurScroll){				_blurTimer.stop();				_blurTimer.removeEventListener(TimerEvent.TIMER, handleBlur, false);			}			} catch (event:Error) {			trace("There was an error when attempting to delete all NpScrollingPanel content. This is the error: "+Error);		}	}}}