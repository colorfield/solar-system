package be.colorfield.rss{	import be.colorfield.ui.box.AbstractBox;		import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.NetStatusEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.geom.Rectangle;	import flash.net.NetConnection;	import flash.utils.getTimer;		import gs.TweenLite;	import com.warmforestflash.ui.ScrollBar;	import org.libspark.ui.SWFWheel;	import org.sse.constant.PrivateParams;
	/**	 * View de type "Box" pour le lecteur RSS	 */	public class RSSBox extends AbstractBox	{				// 1) On passe une variable bidon afin de tromper le cache		//    Moyen alternatif que le pragma no-cache utilisé dans la classe be.colorfield.net.LoaderXML		// 2) Vu que, selon l'emplacement de l'application, le SandBox de sécurité de Flash ne permettra pas 		//    chargement, il ne faudrait pas charger le flux depuis un site web dont nous ne sommes pas certains		//    qu'il comporte un fichier crossdomain.xml. On hébergera donc sur un domaine qui comportera celui-ci		//	  et une tâche cron sera responsable de rapatrier le fichier d'un domaine à l'autre, p.ex. :				// -- CRON ------------------------------------------------------------------------------------------------		//	  0/30 * * * * wget -q -O /home/hypercub/sd/stellarsystem/www/data/rss/Belgium_fr.xml		//    http://www.esa.int/rss/Belgium_fr.xml		//		//    wget -q -O /home/{dir_hote_viruel_apache}/{path}/test.xml http://www.esa.int/rss/Belgium_fr.xml		//    		//    wget : -O = file --output-document=file / -q = quiet => mode "silencieux"		// -- / CRON ----------------------------------------------------------------------------------------------				// private static const RSS_NET_STREAM:String = "http://www.esa.int/rss/TopNews.xml?nocache="+getTimer();		// private static const RSS_NET_STREAM:String = "http://www.esa.int/rss/Belgium_fr.xml?nocache="+getTimer();				// Idéalement, l'adresse du stream est passée en paramètre		private static const RSS_LOCAL_STREAM:String = PrivateParams.PATH_DATA_RSS + "Belgium_fr.xml?nocache="+getTimer();				private static const RSS_BOX_HEADER_HEIGHT:int 	= 35;		private static const RSS_BOX_WIDTH:int 			= 280;		private static const RSS_BOX_HEIGHT:int	 		= 330;		private static const RSS_ITEM_X_INI:int 		= 5;		private static const RSS_ITEM_Y_INI:int 		= 38;		private static const RSS_ITEM_Y_GAP:int 		= 150; // afin d'éviter trop de calculs (height du Sprite),												 	   		   // on définit une hauteur par item				/*		// un MovieClip disposant de la propriété Scale9Grid est stocké dans la bibliothèque de Flash		// ces constantes ne sont donc pas nécessaires		private static const RSS_BOX_WIDTH:int = 265;		private static const RSS_BOX_HEIGHT:int = 600;		*/				private var connection:NetConnection;				private var rss:RSSModel;		private var loadedRss:Array;		private var rssContainer:Sprite;		private var rssContainerRect:Rectangle;		private var dragging:Boolean = false; // scroll par drag				public function RSSBox()		{			createInterface();			rss = new RSSModel();						// choisir la version en fonction de la connexion à internet ou non			connection = new NetConnection();			connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);			connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);			connection.connect(null);		}				private function netStatusHandler(event:NetStatusEvent):void {			switch (event.info.code) {				case "NetConnection.Connect.Success":					rss.parseRSS(RSS_LOCAL_STREAM);					rss.addEventListener(Event.COMPLETE, handleRssComplete);					rss.addEventListener(ProgressEvent.PROGRESS, onProgress);					break;				case "NetStream.Play.StreamNotFound":					// TODO : sélectionner un flux local à la place, p.ex.					// On pourrait également faire un catch d'une exception I/O					trace("Sélection d'un flux interne");					break;			}		}				private function securityErrorHandler(event:SecurityErrorEvent):void {			trace("Erreur de sécurité : " + event);		}				private function createInterface():void {			// panneau à scroller			rssContainer = new Sprite();		}				private function onProgress(event:ProgressEvent):void {			dispatchEvent(event);		}				/**		 * Lorsque le RSS est chargé, on ajoute les items au conteneur		 */		private function handleRssComplete(event:Event):void {						loadedRss = rss.feedItems;			var curY:int = RSS_ITEM_Y_INI;						for each (var item:Object in loadedRss) {				// titre et lien pour chaque item				var rItem:RSSBoxViewItem = new RSSBoxViewItem();				rItem.headerTxt.text = item.title;				rItem.descriptionTxt.htmlText = item.excerpt.value;				rItem.rssItemURL = item.link;								// vu qu'un item par ligne, pas nécessaire de gérer curX				rItem.x = RSS_ITEM_X_INI;				rItem.y = curY;				rssContainer.addChild(rItem);								curY += RSS_ITEM_Y_GAP;			}						// création du masque (zone d'affichage)			var rssMask:Shape = new Shape();			rssMask.graphics.beginFill(0x0000FF);			// rectangle aux bords arrondis pour correspondre à la forme de la fin de la bôite RSS			// spécifique à cette intégration => est donc éligible en tant que paramètre			rssMask.graphics.drawRoundRect(				RSS_ITEM_X_INI,				RSS_ITEM_Y_INI,				RSS_BOX_WIDTH,				RSS_BOX_HEIGHT,				20,				20);					var scrollingPanel:MovieClip = new MovieClip();			addChild(scrollingPanel);			scrollingPanel.addChild(rssContainer);			addChild(rssMask);			rssContainer.mask = rssMask;						// création de la scrollbar			var scrollBar:ScrollBar = new ScrollBar(rssContainer, 													PrivateParams.COLOR_DARK_BLUE, 													PrivateParams.COLOR_MEDIUM_BLUE,													PrivateParams.COLOR_TITLE, 													0xffffff, 15, 15, 4, true,													RSS_BOX_WIDTH,													RSS_BOX_HEIGHT);						scrollingPanel.addChild(scrollBar);			scrollBar.x += RSS_ITEM_X_INI;			scrollBar.y += RSS_BOX_HEADER_HEIGHT;					}					}}