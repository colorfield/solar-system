package org.sse.ui.control{		import caurina.transitions.Tweener;		import flash.display.MovieClip;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;		public class MainSubMenu extends MovieClip	{		// Les enfants du sous-menu provoquent un événement		// MouseEvent.MOUSE_OUT sur le menu même		// et donc cela provoque une fermeture dès qu'on survole un enfant.		// Pour éviter celà, on dispose d'un flag indiquant si le menu est		// éligible à la fermeture.		// private var enableClose = true;		// => modifié : changé pour un Timer qui se déclenche dès qu'on quitte 		// le focus d'un bouton, permet de prévoir aisément tous les cas 		// d'utilisation du menu par l'utilisateur		private static const CLOSE_DELAY:int = 2000; // millisecondes		private var timer:Timer;				public function MainSubMenu()		{			setEventListeners();		}				private function setEventListeners():void{						// écoute du sous-menu			// this.addEventListener(MouseEvent.MOUSE_OUT, closeMenu);						// écoute des enfants			for (var i:uint = 0; i < this.numChildren; ++i){ 				/*				trace('name:' + this.getChildAt(i).name);				trace('\t type:' + typeof (this.getChildAt(i)));				trace('\t' + this.getChildAt(i));				*/								// typeof retourne object à tous les coups...				// => hack afin d'obtenir un type un peu plus précis				if(this.getChildAt(i).toString() == "[object MovieClip]"){										// trace(this.getChildAt(i).name);										this.getChildAt(i).addEventListener(MouseEvent.CLICK,onClick);					this.getChildAt(i).addEventListener(MouseEvent.MOUSE_OVER,onMouseOver);					this.getChildAt(i).addEventListener(MouseEvent.MOUSE_OUT,onMouseOut);				}							}						timer = new Timer(CLOSE_DELAY);								}				private function onClick(e:MouseEvent):void{						// bouton parent			MainMenu.parentBtn.gotoAndPlay("btnActive");			MainMenu.curBtn.gotoAndPlay("btnInactive");			MainMenu.curBtn = MainMenu.parentBtn;						closeMenu();			clickActions(e);					}				/**		 * Méthode "abstraite" implémentée par les sous-classes		 */		internal function clickActions(e:MouseEvent):void{			// 		}				private function onMouseOver(e:MouseEvent):void		{			timer.stop();			timer.removeEventListener(TimerEvent.TIMER, onTimer);						Tweener.addTween(e.target, {alpha:1, time:MainMenu.SM_EASING_DURATION, transition:MainMenu.SM_EASING_TYPE});		}				private function onMouseOut(e:MouseEvent):void		{			timer.start();			timer.addEventListener(TimerEvent.TIMER, onTimer);						// timer = null;						Tweener.addTween(e.target, {alpha:0, time:MainMenu.SM_EASING_DURATION, transition:MainMenu.SM_EASING_TYPE});		}				private function onTimer(e:TimerEvent):void{			// trace("ON TIMER");			closeMenu();		}				/**		 * Doit pouvoir recevoir des événements TimerEvent et MouseEvent		 * donc le paramètre est plus générique (Event)		 */		private function closeMenu(e:Event = null):void		{			timer.removeEventListener(TimerEvent.TIMER, onTimer);						Tweener.addTween(this, {y:MainMenu.SM2_YPOS_BEG,				time:MainMenu.SM_EASING_DURATION,				transition:MainMenu.SM_EASING_TYPE});		}	}}