package be.colorfield.net{	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.HTTPStatusEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.events.EventDispatcher;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLRequest;	import flash.net.URLRequestHeader;		/**	 * Gestion du chargement d'un flux XML	 * Version 1 - Gestion du cache incluse	 * Utilisée pour les XML étant régulièrement mis à jour	 */	public class LoaderXML extends EventDispatcher	{		private var ldr:URLLoader;		private var feedXML:XML;		private var antiCache:Boolean;				public function LoaderXML (noCache:Boolean=false) 		{				antiCache = noCache;			ldr = new URLLoader();			ldr.dataFormat = URLLoaderDataFormat.TEXT;						ldr.addEventListener(Event.OPEN, redirectEvent);			ldr.addEventListener(ProgressEvent.PROGRESS, redirectEvent);			ldr.addEventListener(Event.COMPLETE, onLoadComplete);			ldr.addEventListener(HTTPStatusEvent.HTTP_STATUS, redirectEvent);			ldr.addEventListener(IOErrorEvent.IO_ERROR, redirectEvent);			ldr.addEventListener(SecurityErrorEvent.SECURITY_ERROR, redirectEvent);		}				public function charge (qry:URLRequest):void 		{			// les fichiers XML sont souvent dans le cache du navigateur			// voici un moyen pratique d'éviter cela			if (antiCache) qry.requestHeaders.push (new URLRequestHeader ("pragma", "no-cache"));			ldr.load(qry);			}				private function redirectEvent(e:Event):void		{			dispatchEvent(e);			}				private function onLoadComplete(e:Event):void		{			try 				{				feedXML = new XML(e.currentTarget.data);			}catch (err:Error)			{				trace (err);				}						dispatchEvent(e);		}				public function get donnees():XML 		{			return feedXML;			}	}}