package org.sse.solarsystem {		import away3d.containers.View3D;	import away3d.core.base.Mesh;	import away3d.core.base.Object3D;	import away3d.core.utils.Cast;	import away3d.lights.AmbientLight3D;	import away3d.lights.PointLight3D;	import away3d.materials.BitmapMaterial;	import away3d.materials.ColorMaterial;	import away3d.materials.CompositeMaterial;	import away3d.materials.Dot3BitmapMaterial;	import away3d.materials.EnviroBitmapMaterial;	import away3d.materials.Material;	import away3d.materials.PhongBitmapMaterial;	import away3d.materials.ShadingColorMaterial;	import away3d.materials.WhiteShadingBitmapMaterial;	import away3d.materials.shaders.AmbientShader;	import away3d.materials.shaders.DiffuseDot3Shader;	import away3d.materials.shaders.SpecularPhongShader;	import away3d.primitives.Cube;	import away3d.primitives.GeodesicSphere;	import away3d.primitives.Plane;	import away3d.primitives.RegularPolygon;	import away3d.primitives.Skybox;	import away3d.primitives.Sphere;	import away3d.primitives.Torus;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.display.StageAlign;	import flash.display.StageQuality;	import flash.display.StageScaleMode;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.filters.GlowFilter;	import flash.geom.Vector3D;	import flash.ui.Keyboard;			/**	 * Voyage dans le système solaire	 * Planètes alignées avec un simple jeu de caméras	 * 	 * EXEMPLE D'UTILISATION D'AWAY3D	 * 	 * @deprecated Classe monolithique qui a été refactorée dans un projet dédié	 */	public class PlanetsPerspective extends Sprite {				/*		private static const EARTH_RADIUS:int = 100; //6380km		private static const METRICS_UA:int = 1000; //149 598 000km		*/		private static const EARTH_RADIUS:int = 63.8; //6380km		// liberté prise par rapport à la réalité : réduction de 400x la distance entre les objets		private static const METRICS_UA:int = 1495.68 * 2.5; //149 598 000km				// distance jusqu'à Pluton / 5 => pour la caméra		private static const SOLARSYSTEM_SIZE:int = METRICS_UA*39.44/5;				private static const SUN_X:int = 0;		private static const SUN_Y:int = 0;				// liberté prise par rapport à la réalité : réduction de + de 5x la taille du Soleil		private static const sizeSun:int 		= EARTH_RADIUS*20;//109 !!		private static const sizeMercury:int 	= EARTH_RADIUS*0.387;		private static const sizeVenus:int 		= EARTH_RADIUS*0.95 ;		private static const sizeEarth:int		= EARTH_RADIUS;		private static const sizeMars:int 		= EARTH_RADIUS*0.53;		private static const sizeJupiter:int	= EARTH_RADIUS*11.2;		private static const sizeSaturn:int 	= EARTH_RADIUS*9.3;		private static const sizeUranus:int 	= EARTH_RADIUS*4;		private static const sizeNeptune:int	= EARTH_RADIUS*3.9;		private static const sizePluto:int 		= EARTH_RADIUS*0.18;				private static const N_SEGMENTS:int		= 20;				//-----------------------------------				private var view:View3D;				private var starField:Skybox;		private var earth:Sphere;		private var sun:Mesh;		private var moon:Sphere;		private var sunLight:PointLight3D;				private var earthRotation:Number = Math.PI;		private var moonDistance:Number = 400;		private var moonEllipse:Number = 5;				private var CAM_Y_BASE:Number;		private var CAM_X_BASE:Number;		private var mouseMultiplier:Number = -50;		private var mouseEasing:Number = .2;		private var simulationRate:Number = 1;				private var cameraLocations:Array;		private var cameraLocIndex:int = -1;				private var paused:Boolean = false;		private var simRateAcc:Number = 0;				private var sSun:Sphere;		private var sMercury:Sphere;		private var sVenus:Sphere;		private var sEarth:Sphere;		private var sMars:Sphere;		private var sJupiter:Sphere;		private var sSaturn:Sphere;		private var sUranus:Sphere;		private var sNeptune:Sphere;		private var sPluto:Sphere;				[Embed(source="../../../assets/images/textures/sphere/sunmap.jpg")]		private var Sun:Class;		private var mSun:BitmapMaterial = new BitmapMaterial(Cast.bitmap(Sun));				[Embed(source="../../../assets/images/textures/sphere/mercurymap.jpg")]		private var Mercury:Class;		//private var mMercury:WhiteShadingBitmapMaterial = new WhiteShadingBitmapMaterial(Cast.bitmap(Mercury));		private var mMercury:BitmapMaterial = new BitmapMaterial(Cast.bitmap(Mercury));				[Embed(source="../../../assets/images/textures/sphere/venusmap.jpg")]		private var Venus:Class;		private var mVenus:BitmapMaterial = new BitmapMaterial(Cast.bitmap(Venus));				[Embed(source="../../../assets/images/textures/sphere/earthmap1k.jpg")]		private var Earth2:Class;		private var mEarth:BitmapMaterial = new BitmapMaterial(Cast.bitmap(Earth2));				[Embed(source="../../../assets/images/textures/sphere/mars_1k_color.jpg")]		private var Mars:Class;		private var mMars:BitmapMaterial = new BitmapMaterial(Cast.bitmap(Mars));				[Embed(source="../../../assets/images/textures/sphere/jupitermap.jpg")]		private var Jupiter:Class;		private var mJupiter:BitmapMaterial = new BitmapMaterial(Cast.bitmap(Jupiter));				[Embed(source="../../../assets/images/textures/sphere/saturnmap.jpg")]		private var Saturn:Class;		private var mSaturn:BitmapMaterial = new BitmapMaterial(Cast.bitmap(Saturn));				[Embed(source="../../../assets/images/textures/sphere/uranusmap.jpg")]		private var Uranus:Class;		private var mUranus:BitmapMaterial = new BitmapMaterial(Cast.bitmap(Uranus));				[Embed(source="../../../assets/images/textures/sphere/neptunemap.jpg")]		private var Neptune:Class;		private var mNeptune:BitmapMaterial = new BitmapMaterial(Cast.bitmap(Neptune));				[Embed(source="../../../assets/images/textures/sphere/plutomap1k.jpg")]		private var Pluto:Class;		private var mPluto:BitmapMaterial = new BitmapMaterial(Cast.bitmap(Pluto));						private var spheres:Array;		private var materials:Array;		private var sizes:Array;		private var distances:Array;						public function PlanetsPerspective() { 			this.addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			// nécessaire pour supprimer tous les autres écouteurs d'événement			// => lorsqu'on change d'écran			this.addEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);		}				private function onRemovedFromStage(event:Event):void{			// trace("REMOVED_FROM_STAGE: " + event.target.name + " : " + event.currentTarget.name);						removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);			removeEventListener(Event.ENTER_FRAME, render);			removeEventListener(MouseEvent.MOUSE_WHEEL, zoom);			removeEventListener(MouseEvent.MOUSE_UP, changeCameraLocation);						stage.removeEventListener(Event.RESIZE, updateView);			stage.removeEventListener(KeyboardEvent.KEY_DOWN, handleKeyDown);			stage.removeEventListener(KeyboardEvent.KEY_UP, handleKeyUp);		}						private function onAddedToStage(event:Event):void {			// trace("ADDED_TO_STAGE: " + event.target.name + " : " + event.currentTarget.name);						removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			init();						cameraLocations = new Array();			cameraLocations.push( { loc:new Vector3D(SOLARSYSTEM_SIZE/10, 0, 150, 0), lookAt:new Vector3D(0, 0, 0, 0), attachTo:sEarth, name:"Venus" } );			cameraLocations.push( { loc:new Vector3D(SOLARSYSTEM_SIZE/7, 0, 150, 0), lookAt:new Vector3D(0, 0, 0, 0), attachTo:sEarth, name:"Terre" } );			cameraLocations.push( { loc:new Vector3D(SOLARSYSTEM_SIZE/5, 0, 150, 0), lookAt:new Vector3D(0, 0, 0, 0), attachTo:sEarth, name:"Mars" } );			cameraLocations.push( { loc:new Vector3D(SOLARSYSTEM_SIZE/1.2, 0, 10, 0), lookAt:new Vector3D(0, 0, 0, 0), attachTo:sEarth, name:"Jupiter" } );			cameraLocations.push( { loc:new Vector3D(SOLARSYSTEM_SIZE/10, 0, SOLARSYSTEM_SIZE/5, 0), lookAt:new Vector3D(SOLARSYSTEM_SIZE/10, 0, 0, 0), attachTo:null, name:"côté, système interne" });			cameraLocations.push( { loc:new Vector3D(SOLARSYSTEM_SIZE*3, 0, SOLARSYSTEM_SIZE/2.5, 0), lookAt:new Vector3D(0, 0, 0, 0), attachTo:null, name:"arrière" } );			cameraLocations.push( { loc:new Vector3D(SOLARSYSTEM_SIZE/2, SOLARSYSTEM_SIZE*2, -SOLARSYSTEM_SIZE/4, 0), lookAt:new Vector3D(SOLARSYSTEM_SIZE/2, 0, -SOLARSYSTEM_SIZE/4, 0), attachTo:null, name:"dessus" } );						changeCameraLocation();						addEventListener(Event.ENTER_FRAME, render, false, 0, true);			addEventListener(MouseEvent.MOUSE_WHEEL, zoom, false, 0, true);			addEventListener(MouseEvent.MOUSE_UP, changeCameraLocation, false, 0, true);						stage.addEventListener(Event.RESIZE, updateView, false, 0, true);			stage.addEventListener(KeyboardEvent.KEY_DOWN, handleKeyDown, false, 0, true);			stage.addEventListener(KeyboardEvent.KEY_UP, handleKeyUp, false, 0, true);		}						private function init():void {			// View			view = new View3D();			view.x = stage.stageWidth / 2;			view.y = stage.stageHeight / 2;			addChild(view);						sunLight = new PointLight3D( { x:0, y:0, z: 0, brightness:5, ambient:30, diffuse:500, specular:180 } );			//view.scene.addChild(sunLight as Object3D);						//--------------------------------------------------------------------						// seront des valuObjects distincts ensuite, avec leurs propriétés			// cf. nouvelle implémentation dans le projet dédié			spheres = new Array();			materials = new Array();			sizes = new Array();			spheres = [sSun,sMercury,sVenus,sEarth,sMars,sJupiter,sSaturn,sUranus,sNeptune,sPluto];			materials = [mSun,mMercury,mVenus,mEarth,mMars,mJupiter,mSaturn,mUranus,mNeptune,mPluto];			sizes = [sizeSun,sizeMercury,sizeVenus,sizeEarth,sizeMars,sizeJupiter,sizeSaturn,sizeUranus,sizeNeptune,sizePluto];			//--- soleil = 0			distances = [0,METRICS_UA*0.387,METRICS_UA*0.723,METRICS_UA,METRICS_UA*1.524,METRICS_UA*5.203,METRICS_UA*9.54,METRICS_UA*19.19,METRICS_UA*30.06,METRICS_UA*39.44];			//--- terre = 0			//distances = [METRICS_UA,- METRICS_UA*0.387,- METRICS_UA*0.723, 0,METRICS_UA*1.524,METRICS_UA*5.203];						for(var i:int=0;i<spheres.length;i++){				spheres[i] = new Sphere();				spheres[i].x = distances[i];				spheres[i].y = SUN_Y;				spheres[i].segmentsH = N_SEGMENTS;				spheres[i].segmentsW = N_SEGMENTS;				spheres[i].radius = sizes[i];				spheres[i].material = materials[i];				view.scene.addChild(spheres[i]);			}						//--------------------------------------------------------------------			//		   OLD (représentation Soleil - Terre - Lune)			//--------------------------------------------------------------------						//------- Soleil			//var sunMat:ColorMaterial = new ColorMaterial(0xffffff);			sun = new RegularPolygon( { /*material:sunMat,*/ radius:100, sides:32, x:2400, y:0, z: -1200 } );			sun.rotationZ = 90;			view.scene.addChild(sun);			sun.ownCanvas = true;			sun.filters = [new GlowFilter(0xffffbe, 1, 12, 12, 3, 3, false, false), new GlowFilter(0xffffbe, 1, 12, 12, 3, 3, true, false)];						//------- Terre			//var earthBmp:Bitmap = new Earth() as Bitmap;			//---var earthMat:ColorMaterial = new ColorMaterial(0x4b4b4b);			//var earthMat:BitmapMaterial = new BitmapMaterial(earthBmp.bitmapData);			//---var earthMat:WhiteShadingBitmapMaterial = new WhiteShadingBitmapMaterial(earthBmp.bitmapData); 			//---earthMat.ambient_brightness = 2;			//---earthMat.diffuse_brightness = 1.7;			//---earthMat.specular_brightness = 0;			earth = new Sphere( { /*material:earthMat,*/ radius:150, segmentsW:32, segmentsH:18, y:0, x:0, z:0 } );			//earth.material = earthMat;			earth.rotationZ = -8;			view.scene.addChild(earth);						//------- Lune			//var moonBmp:Bitmap = new Moon() as Bitmap;			//var moonMat:BitmapMaterial = new BitmapMaterial(moonBmp.bitmapData);			//---var moonMat:WhiteShadingBitmapMaterial = new WhiteShadingBitmapMaterial(moonBmp.bitmapData);			//---moonMat.ambient_brightness = 0;			//---moonMat.diffuse_brightness = 1.2;			//---moonMat.specular_brightness = 0;			moon = new Sphere( { /*material:moonMat,*/ radius:16, segmentsW:24, segmentsH:12, y:0, x:moonDistance, z:moonDistance } );			view.scene.addChild(moon);						/*			var starBmp:Bitmap = new Stars() as Bitmap;			var starFieldMat:BitmapMaterial = new BitmapMaterial(starBmp.bitmapData);			starField = new Skybox(starFieldMat, starFieldMat, starFieldMat, starFieldMat, starFieldMat, starFieldMat);			view.scene.addChild(starField);			*/			//---sunLight.lookAt(new Vector3D(0, 0, 0));					}				private function handleKeyDown(k:KeyboardEvent):void {			switch (k.keyCode) {				// barre d'espace				case 32:					paused = true;					break;				case Keyboard.LEFT:				case Keyboard.DOWN:					simRateAcc = -.1;					break;				case Keyboard.RIGHT:				case Keyboard.UP:					simRateAcc = .1; 					break;			}		}				private function handleKeyUp(ke:KeyboardEvent):void {			paused = false;			simRateAcc = 0;		}				private function zoom(me:MouseEvent):void {			if (view.camera.zoom < 4 && me.delta < 1) return;			if (view.camera.zoom > 50 && me.delta > 1) return;						var nz:Number = me.delta / 10;			view.camera.zoom += nz;		}				private function changeCameraLocation(e:Event = null):void {			if (cameraLocIndex > -1 && cameraLocations[cameraLocIndex].attachTo != null)				cameraLocations[cameraLocIndex].attachTo.visible = true;						cameraLocIndex++;			if (cameraLocIndex == cameraLocations.length) cameraLocIndex = 0;						view.camera.position = cameraLocations[cameraLocIndex].loc;			if (cameraLocations[cameraLocIndex].lookAt != null) view.camera.lookAt(cameraLocations[cameraLocIndex].lookAt);						CAM_Y_BASE = view.camera.rotationY;			CAM_X_BASE = view.camera.rotationX;						view.camera.zoom = 10;						if (cameraLocations[cameraLocIndex].name == "top") {				sun.rotationZ = 0;			} else {				sun.rotationZ = 90;			}		}				private function updateView(e:Event):void {			view.x = stage.stageWidth / 2;			view.y = stage.stageHeight / 2;		}				private function render(event:Event):void {						// ne raffraîchit pas le rendu si en pause			if (paused) return;						// limite les vitesses de simulation			if(simRateAcc != 0) {				simulationRate += simRateAcc;				if (simulationRate < .5) simulationRate = .5;				//---if (simulationRate > 20) simulationRate = 20;				if (simulationRate > 100) simulationRate = 100;			}						// TODO : vitesse de rotation différente par objet						earth.rotationY -= simulationRate;			moon.rotationY += simulationRate * 0.1;						moon.x = Math.cos(earthRotation) * moonDistance;			moon.z = Math.sin(earthRotation) * moonDistance;			moon.y = Math.sin(earthRotation) * moonEllipse;			earthRotation -= (simulationRate * 0.1) / 180 * Math.PI;									if(cameraLocations[cameraLocIndex].attachTo == null) {				var mx:Number = CAM_Y_BASE + (mouseX - stage.stageWidth / 2) / mouseMultiplier;				var my:Number = CAM_X_BASE + (mouseY - stage.stageHeight / 2) / mouseMultiplier;								var vx:Number = mx - view.camera.rotationY;				var vy:Number = my - view.camera.rotationX;								view.camera.rotationY += vx * mouseEasing;				view.camera.rotationX += vy * mouseEasing;								var fgw:Number = view.camera.rotationY;				var fgh:Number = view.camera.rotationX;			} else {				var att:Mesh = cameraLocations[cameraLocIndex].attachTo as Mesh;				att.visible = false;				view.camera.position = att.position;				if (att == moon) view.camera.lookAt(cameraLocations[cameraLocIndex].lookAt);				else if (att == earth) view.camera.rotationY = earth.rotationY * -1;			}						if (cameraLocations[cameraLocIndex].name == "top") {				sun.rotationX = 0;			} else {				var sx:Number = sun.x - view.camera.x;				var sz:Number = sun.z - view.camera.z;				var sa:Number = Math.atan2(sz, sx);				sun.rotationX = sa  * 180 / Math.PI;			}						//-----------------------------------------------------			// masque le premier rendu			earth.visible = false;			moon.visible = false;			sun.visible = false;						// soleil uniquement			spheres[0].rotationY -= simulationRate / 10;						// planètes : vitesse différente du soleil			for(var i:int=1;i<spheres.length;i++){				spheres[i].rotationY -= simulationRate;			}			//-----------------------------------------------------						view.render();		}	}}