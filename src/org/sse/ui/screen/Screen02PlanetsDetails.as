package org.sse.ui.screen{			import away3d.containers.View3D;	import away3d.core.utils.Cast;	import away3d.events.MouseEvent3D;	import away3d.lights.PointLight3D;	import away3d.materials.BitmapMaterial;	import away3d.materials.WhiteShadingBitmapMaterial;	import away3d.primitives.Cube;	import away3d.primitives.Sphere;		import caurina.transitions.Tweener;		import be.colorfield.ui.Application;	import be.colorfield.ui.screen.IScreen;	import be.colorfield.ui.screen.ScreenAbstract;		import flash.display.Loader;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.MouseEvent;		import noponies.net.LoadXml;	import noponies.scrollingpanel.events.NpScrollingPanelEvent;	import noponies.scrollingpanel.ui.NpScrollingPanel;		import org.papervision3d.objects.primitives.Arrow;		/**	 * ECRAN contenant les fiches détaillées de chaque planète.	 * Celui-ci est en cours de réalisation, je l'ai laissé comme exemple 	 * d'utilisation peu heureuse de l'open source. Le composant écrit par un tiers	 * s'est révélé très complexe à l'usage, aussi j'ai choisit d'écrire mon propre	 * composant de panneau à scroller.	 */	public class Screen02PlanetsDetails extends ScreenAbstract implements IScreen	{				//------------------------------------------------------------------------		//	SCROLLING PANEL		//------------------------------------------------------------------------				private static const PANEL_MARGIN:int = 120;				private var panels:Vector.<LoaderPanel>;				private var loaderPanel:LoaderPanel;		private var scrollingPanel:NpScrollingPanel = new NpScrollingPanel();				private var leftArrow:PanelArrow;		private var rightArrow:PanelArrow;				//------------------------------------------------------------------------		//	PLANETES AWAY3D		//------------------------------------------------------------------------					[Embed(source="../../../../assets/images/textures/sphere/mars_1k_color.jpg")]		private var TextureMars:Class;		private var mMars:BitmapMaterial = new BitmapMaterial(Cast.bitmap(TextureMars));						private static const ROTATION_SPEED:Number = 0.5;				private var view:View3D;		private var sphere:Sphere;				public function Screen02PlanetsDetails()		{			addEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);		}						private function onRemovedFromStage(e:Event):void{			leftArrow.removeEventListener(MouseEvent.CLICK, leftClick);			rightArrow.removeEventListener(MouseEvent.CLICK, rightClick);			removeEventListener(Event.ENTER_FRAME, onEnterFrame);		}				/**		 * Création des éléments et de leurs options d'affichage		 */		override public function buildElements():void		{			loadNew();		}				//move right and left		//note the equations used in the methods below. The reason for this is that the scroller		//returns a percent value as a .7 etc. And, in this instance I want to pass back rounded values		//to the scroller, so we need to increase the value of the scrollers position in order to be able to		//round it, as Math.round returns an int, and we need a number.		private function leftClick(event:MouseEvent):void {			var curPos:Number;			//curPos = (((scrollingPanel.panelScrollPos*100)/100)*1)-.2;			//scrollingPanel.panelScrollPos = curPos;			trace(scrollingPanel.panelContentWidth);			trace(scrollingPanel.panelContentHeight);						curPos = panels[0].x;			trace("LEFT POS : " + curPos);			scrollingPanel.panelScrollPos = 0;			//Tweener.addTween(scrollingPanel,{x:curPos, time:1, transition:"linear"});					}				private function rightClick(event:MouseEvent):void {			var curPos:Number;			//curPos = (((scrollingPanel.panelScrollPos*100)/100)*1)+.2;			//curPos = Application.MAIN_STAGE.stageWidth *2;			//scrollingPanel.panelScrollPos = curPos;			//curPos = panels[1].x;			curPos = panels[0].width;			trace("RIGHT POS : " + curPos);			scrollingPanel.panelScrollPos = 200;			Tweener.addTween(scrollingPanel,{x:- 800, time:1, transition:"linear"});		}				//this method kills the existing scrollers and creates the new one		//function loadNew(event:MouseEvent):void {		private function loadNew():void {						//show arrow nav			/*			leftArrow.visible = rightArrow.visible = true;			leftArrow.y = rightArrow.y = 140;			leftArrow.x = 50;			rightArrow.x = stage.stageWidth-60;			*/			//call the create new scroller method			createNewScroller();		}						// définition des paramètres du scroller		private function createNewScroller():void {			scrollingPanel.resizePanelMaskToStage = false;			scrollingPanel.panelMaskHeight = 600;			scrollingPanel.panelMaskWidth = 800;			scrollingPanel.mouseScrolling = false;			scrollingPanel.panelBgColour = 0x000000;			scrollingPanel.panelReflection = true			scrollingPanel.scrollSpeed = 60;			scrollingPanel.y = 150;			scrollingPanel.x = 0;			addChild(scrollingPanel);					createStructure()		}				private function createStructure():void {					var spOptions:Object = {x:0,y:0,offSetY:PANEL_MARGIN};			// ajout des éléments + options à l'écran						// on crée les flèches ensuite, afin qu'elles soient au-dessus du panel			var lArrowOptions:Object = {x:0,y:.5,offSetX:40};			var rArrowOptions:Object = {x:1,y:.5,offSetX:-40};						leftArrow = new PanelArrow();			leftArrow.rotation -= 180; // vu que PanelArrow est définie dans le sens "droite"			rightArrow = new PanelArrow();						leftArrow.addEventListener(MouseEvent.CLICK, leftClick)			rightArrow.addEventListener(MouseEvent.CLICK, rightClick)			leftArrow.buttonMode = rightArrow.buttonMode = true;						addElement(scrollingPanel,spOptions);			addElement(leftArrow,lArrowOptions);			addElement(rightArrow,rArrowOptions);					}				/**		 * Opération effectuée uniquement lorsque le display Object 		 * constitué par cette classe est accessible sur la scène		 */		override public function postDisplayOperations():void{			populatePanel();		}				private function populatePanel():void{					panels = new Vector.<LoaderPanel>();						for (var i:int = 0; i< 2; i++) {				loaderPanel = new LoaderPanel();				panels.push(loaderPanel);				loaderPanel.width = Application.MAIN_STAGE.stageWidth;				scrollingPanel.addContentItem(loaderPanel);				}						// on active le scrolling une fois que les panels sont disponibles			scrollingPanel.enableScrolling();						createPlanets();		}				//------------------------------------------------------------------------		//	PLANETES AWAY3D		//------------------------------------------------------------------------						private function createPlanets():void{						sphere = new Sphere();			sphere.segmentsW = 32;			sphere.segmentsH = 32;			sphere.x = -200;			sphere.y = 200; // !! espace de coordonnées inversé d'Away3D			//var marsBmp:Bitmap = new TextureMars() as Bitmap;			//var marsMat:BitmapMaterial = new BitmapMaterial(marsBmp.bitmapData);			//sphere.material = mMars.bitmapData;			sphere.material = mMars;						view = new View3D();						// positionnement du point de fuite au centre			view.x = Application.MAIN_STAGE.stageWidth/2;			view.y = Application.MAIN_STAGE.stageHeight/2;						panels[0].addChild(view);			view.scene.addChild(sphere);						/*			panels[1].addChild(view);			view.scene.addChild(sphere);			*/						addEventListener(Event.ENTER_FRAME, onEnterFrame);		}						private function onEnterFrame(e:Event):void		{			sphere.rotationY += ROTATION_SPEED;			view.render();		}												}}