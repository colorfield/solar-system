/* AS3* Copyright 2009 noponies.*/package noponies.ui{	import flash.display.InteractiveObject;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.geom.Rectangle;	import flash.events.Event;	import noponies.events.NpScrollBarEvent;	import fl.transitions.Tween;	import fl.transitions.TweenEvent;	import fl.transitions.easing.Strong;	/**	 *  The NpScrollBar class is a simple implmentation of a scroll bar. 	*	@langversion ActionScript 3.0	*	@Flash Player 9.0.28.0	*	@author noponies - 2009	*   @version 1	 */	public class NpScrollBar extends Sprite {		//--------------------------------------		// PRIVATE INSTANCE PROPERTIES		//--------------------------------------		private var _scrubBarTrack:Sprite;		private var _dragBox:*;		private var _percentChange:Number = 0;		private var _usingDefaults:Boolean = true;		private var _scrollDirection:String;		private var _scrubBarColour:uint = 0xCCCCCC;//defaults		private var _scrubBarAlpha:Number = 1;//default		private var _slideBarHeight:int = 10;		private var _slideBarWidth:int = 100;		private var _dragBoxColour:uint = 0x000000;//defaults		private var _dragBoxHeight:int = 10;		private var _dragBoxWidth:int = 10;		private var _dragButtonMode:Boolean = false;//default		private var _offSetY:int = 0;		private var _offSetX:int = 0;		private var _target:Number;		private var _myTween:Tween;		private var _updateValuesOnTween:Boolean = true;		//--------------------------------------		// GETTERS/SETTERS		//--------------------------------------		/**		 *	Get / Set the <code>x</code> Offset off the scroll track handle from the Scroll Track. This allows you to create scrollers than have thinner or wider scrolling tracks compared to the scroll track handle.		 *	@default 0		 *	@return int		 */		public function get scrollHandleOffSetX():int {			return _offSetX;		}		/**		* @private		*/		public function set scrollHandleOffSetX(new_offSetX:int):void {			_offSetX = new_offSetX;		}		/**		 *	Get / Set the <code>y</code> Offset off the scroll track handle from the Scroll Track. This allows you to create scrollers than have thinner or wider scrolling tracks compared to the scroll track handle.		 *	@default 0		 *	@return int		 */		public function get scrollHandleOffSetY():int {			return _offSetY;		}		/**		* @private		*/		public function set scrollHandleOffSetY(new_offSetY:int):void {			_offSetY = new_offSetY;		}		/**		 *	Set the scroll tracks colour as a hex, or uint value.		 *	@default 0xCCCCCC		 *	@return uint representing colour of scrollTrack		 */		public function get scrollTrackColour():uint {			return _scrubBarColour;		}		/**		* @private		*/		public function set scrollTrackColour(newColour:uint):void {			_scrubBarColour = newColour;		}		/**		 *	Set the scroll tracks alpha value for its colour.		 *	@default 1		 *	@return Number		 */		public function get scrollTrackAlpha():Number {			return _scrubBarAlpha;		}		/**		* @private		*/		public function set scrollTrackAlpha(newAlpha:Number):void {			_scrubBarAlpha = newAlpha;		}		/**		 *	Set the scroll tracks <code>height</code> as an int pixel value. 		 *	@return int Representing the height of the scroll track.		 */				public function get scrollTrackHeight():int {			return _slideBarHeight;		}		/**		* @private		*/		public function set scrollTrackHeight(newHeight:int):void {			_slideBarHeight = newHeight;			updateProps();		}		/**		 *	Get / Set the scrolltracks <code>width</code> as an int pixel value.		 *	@return int Representing the width of the scroll track.		 */		public function get scrollTrackWidth():int {			return _slideBarWidth;		}		/**		* @private		*/		public function set scrollTrackWidth(newWidth:int):void {			_slideBarWidth = newWidth;			updateProps();		}		/**		 *	Get / Set the scroll track handles button mode for triggering the hand cursor.		 *	@default false		 *	@return Boolean representing whether or not to enable buttonMode. A value of <code>true</code> enables buttonMode. A value of <code>false</code> disables buttonMode.		 */		public function get scrollHandleButtonMode():Boolean {			return _dragButtonMode;		}		/**		* @private		*/		public function set scrollHandleButtonMode(newBtnMode:Boolean):void {			_dragButtonMode = newBtnMode;		}		/**		 *	Set the scroll track handles <code>height</code> as an int pixel value.		 *	@return void		 */		public function set scrollHandleHeight(newHeight:int):void {			_dragBoxHeight = newHeight;			updateProps();		}		/**		 *	Get / Set the scroll track handles <code>width</code> as an int pixel value.		 *	@return void		 */		public function set scrollHandleWidth(newWidth:int):void {			_dragBoxWidth = newWidth;			updateProps();		}		/**		 *	Get / Set the scroll track handle colour as a hex or uint value.		 *	@default 0x000000		 *	@return uint representing colour of scroll handle		 */		public function get scrollHandleColour():uint {			return _dragBoxColour;		}		/**		* @private		*/		public function set scrollHandleColour(newDrgColour:uint):void {			_dragBoxColour = newDrgColour;		}		//--------------------------------------		// CONSTRUCTOR		//--------------------------------------		/**		*	You can pass in existing display list assets for the scrolling track and for the scroll track handle. If you don't pass		 *	in valid objects, the class defaults to drawing its own. Adjust your clips registration points to offset their positions relative to each other.		 *	<p>See the various getter/setter methods for setting scrollTrack and scroll track handle properties. To access the scrollers 		 *	<code>percentChange</code> property, you can either use the classes public method <code>getScrollPercent</code> or add an event listener for the SCROLL_CHANGE event, 		 *	and access the events <code>scrollPercent</code> property.</p>		 *	<p>The class also has a public setter method <code>setScrollPercent</code> which you can use to position the scroll track handle on the scroll track via actionScript. A typical use for this would		 *	be to set the scroll track handle position to match the volume of a playing .mp3 at load time.</p>		 *	@param scrollDirection String indicating what orientation the scrollBar is in. Valid values are "horizontal" or "vertical".		 *	@param dragBox InteractiveObject. Use this to pass in a premade scroll track handle asset. Default is null.		 *	@param scrubBarTrack UnTyped parameter. Use this to pass in a premade scroll track asset. Default is null.		 *	<br/><br/>		 * <listing version="3.0">		 *	//Create a new instance of the NpScrollBar class, set it slide horixontally and pass in two existing display assets		 *	var mySlider:NpScrollBar = new NpScrollBar("horizontal", handleInsance, scrollTrackInstance);		 *	</listing>		 *			 *	@see #scrollTrackColour		 *	@see #scrollTrackHeight		 *	@see #scrollTrackWidth		 *	@see #scrollHandleColour		 *	@see #scrollHandleHeight		 *	@see #scrollHandleWidth		 *	@see #scrollHandleButtonMode		 *	@see #scrollHandleHandleOffSetX		 *	@see #scrollHandleHandleOffSetY		 		 *	@see noponies.events.NpScrollBarEvent#SCROLL_CHANGE		*	@example Example Useage		 *		 * <listing version="3.0">		 *	var volumeSlider:NpScrollBar;		 *  volumeSlider = new NpScrollBar("horizontal");		 *	volumeSlider._dragBoxColour = 0x333333;	 	 *	volumeSlider.sliderBarHeight = 5;		 *	volumeSlider.sliderBarWidth = 200;		 *	volumeSlider.dragBarHeight = 5;		 *	volumeSlider.dragBarButtonMode = true;		 *	volumeSlider.x = 10;		 *	volumeSlider.y = 495;		 *	addChild(volumeSlider);		 *	volumeSlider.addEventListener(NpScrollBarEvent.SCROLL_CHANGE, changeVolume);		 *			 *	function changeVolume(event:NpScrollBarEvent):void {		 *		someintsance.volume = event.scrollPercent;		 *	}		 * </listing>		 *		 */		public function NpScrollBar(scrollDirection:String = "vertical", dragBox:InteractiveObject = null, scrubBarTrack:* = null) {			//error checking - check if we have an appropriate orientation mode			switch (scrollDirection.toLowerCase()) {				case "horizontal" :					this._scrollDirection = scrollDirection.toLowerCase();					break;				case "vertical" :					this._scrollDirection = scrollDirection.toLowerCase();					break;				default :					throw new Error("Problem :The direction parameter passed " + "\"" + scrollDirection + "\"" + " does not match the allowed orientation modes, which are: \"horizontal\", \"vertical\"");			}			//check to see if we have objects passed into to class to act as ui elements			if (dragBox != null) {				this._dragBox = dragBox;				_usingDefaults = false;			}			if (_scrubBarTrack != null) {				this._scrubBarTrack = scrubBarTrack;				_usingDefaults = false;			}			addEventListener(Event.ADDED_TO_STAGE,  handleStageAdd);			addEventListener(Event.REMOVED_FROM_STAGE, handleStageRemove);		}		//--------------------------------------		//		// PUBLIC METHODS		//		//--------------------------------------		/**		 *	Set position of scroll track handle on scroll track. Set as a % of slider bar width or height, depending on what orientation mode the slider is current in. The useable value range is <code>0-1</code>.		 *	@param Number representing the position to scroll to.		 *	@param Boolean (Default = true) Whether or not to dispatch an event to listeners that scroll position has changed.		 *	@param Boolean (Default = true) Whether or not to tween drag hangle to position. Listeners are updated of scroll position change, inline with the update parameter.		 *	@return void		 */		public function setScrollPercent(newPos:Number, update:Boolean = true, tweenToPos:Boolean = true):void {			if (newPos > 1) newPos = 1;			if (newPos < 0) newPos = 0;			if (_dragBox == null && _scrubBarTrack == null) return;			if (update) {				if (tweenToPos) {					doTween(newPos, update);				} else {					if (_scrollDirection == "horizontal") {						_dragBox.x = _usingDefaults ? (_slideBarWidth-_dragBox.width)*newPos : ((_slideBarWidth-_dragBox.width)*newPos)+_scrubBarTrack.getBounds(stage).x;					}					else {						_dragBox.y = _usingDefaults ? (_slideBarHeight-_dragBox.height)*newPos : ((_slideBarHeight-_dragBox.height)*newPos)+_scrubBarTrack.getBounds(stage).y;					}					updatePercent();				}			} else {				if (tweenToPos) {					doTween(newPos, update);				} else {					if (_scrollDirection == "horizontal") {						_dragBox.x = _usingDefaults ? (_slideBarWidth-_dragBox.width)*newPos : ((_slideBarWidth-_dragBox.width)*newPos)+_scrubBarTrack.getBounds(stage).x;					}					else {						_dragBox.y = _usingDefaults ? (_slideBarHeight-_dragBox.height)*newPos : ((_slideBarHeight-_dragBox.height)*newPos)+_scrubBarTrack.getBounds(stage).y;					}				}			}		}		/**		 *	Get the current scrollPercent value. Returns an Number in the 0-1 range.		 *	@return Number representing the current scrollPercent value.		 *	@default 0		 */		public function getScrollPercent():Number {			return _percentChange;		}		//--------------------------------------		//		// EVENT LISTENERS && PRIVATE INSTANCE METHODS		//		//--------------------------------------		private function handleStageAdd(event:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, handleStageAdd);			//these only run if we are not using passed in drag assets			//track			if (_scrubBarTrack == null) {				_scrubBarTrack = new Sprite();				_scrubBarTrack.graphics.beginFill( _scrubBarColour, _scrubBarAlpha );				_scrubBarTrack.graphics.drawRect( 0, 0, _slideBarWidth, _slideBarHeight );				_scrubBarTrack.graphics.endFill();				addChild(_scrubBarTrack);			}			else {				_scrubBarTrack.x = this.x;				_scrubBarTrack.y = this.y;				_slideBarHeight = _scrubBarTrack.height;				_slideBarWidth = _scrubBarTrack.width;			}			//drag handle			if (_dragBox == null) {				_dragBox = new Sprite();				_dragBox.graphics.beginFill( _dragBoxColour, 1 );				_dragBox.graphics.drawRect( 0, 0, _dragBoxWidth, _dragBoxHeight );				_dragBox.graphics.endFill();				addChild(_dragBox);				_dragBox.y = _offSetY;				_dragBox.x = _offSetX;			}			else {				_dragBox.x = this.x + _offSetX;				_dragBox.y = this.y + _offSetY;			}			//add event listeners			_dragBox.buttonMode = _dragButtonMode;			_dragBox.addEventListener( MouseEvent.MOUSE_DOWN, _dragBoxPress );			_dragBox.addEventListener(MouseEvent.ROLL_OUT, _dragBoxOut);			_dragBox.addEventListener(MouseEvent.ROLL_OVER, _dragBoxOver);			stage.addEventListener(MouseEvent.MOUSE_UP, _dragBoxRelease );			_scrubBarTrack.addEventListener(MouseEvent.MOUSE_DOWN, sliderBarClick);		}		private function updateProps():void {			if (_scrubBarTrack != null && _usingDefaults) {				_scrubBarTrack.width = _slideBarWidth;				_scrubBarTrack.height = _slideBarHeight;			}			if (_dragBox != null && _usingDefaults) {				_dragBox.width = _dragBoxWidth;				_dragBox.height = _dragBoxHeight;			}		}		//--------------------------------------		// UPDATE SCROLL CHANGE VAR - DISPATCH SCROLL CHANGE EVENT		//--------------------------------------		//update track percent, and dispatch event. 		private function updatePercent(event:MouseEvent = null, update:Boolean = true):void {			if (_scrollDirection == "horizontal") {				_usingDefaults ? _percentChange = (_dragBox.x-_scrubBarTrack.x) / (_scrubBarTrack.width - _dragBox.width) : _percentChange = (_dragBox.getBounds(stage).x- _scrubBarTrack.getBounds(stage).x) / (_scrubBarTrack.width - _dragBox.width);			}			else {				_usingDefaults ? _percentChange = (_dragBox.y-_scrubBarTrack.y) / (_scrubBarTrack.height - _dragBox.height) : _percentChange = (_dragBox.getBounds(stage).y-_scrubBarTrack.getBounds(stage).y) / (_scrubBarTrack.height - _dragBox.height);			}			dispatchEvent(new NpScrollBarEvent(NpScrollBarEvent.SCROLL_CHANGE,true, true, _percentChange));		}		//--------------------------------------		// HANDLE CLICK ON THUMB TRACK		//--------------------------------------		private function sliderBarClick(event:MouseEvent):void {			_scrollDirection == "horizontal" ? doTween(event.localX / _scrubBarTrack.width):doTween(event.localY / _scrubBarTrack.height);		}		//--------------------------------------		// HANDLE DRAGGING THE DRAG HANDLE		//--------------------------------------		//set up new rects to constrain drag etc		//the offsets in here have not really been tested!!		private function _dragBoxPress( event:MouseEvent ):void {			if (_myTween != null && _myTween.isPlaying) {				_myTween.stop();			}						if (_scrollDirection == "horizontal") {				_usingDefaults ? _dragBox.startDrag(false,new Rectangle(0,_scrubBarTrack.y + _offSetY,_scrubBarTrack.width - _dragBox.width,0)):_dragBox.startDrag(false,new Rectangle(this.x,this.y + _offSetY,_scrubBarTrack.width - _dragBox.width,0));			}			else {				_usingDefaults ? _dragBox.startDrag(false,new Rectangle(0 + _offSetX,_scrubBarTrack.y,0,_scrubBarTrack.height - _dragBox.height)):_dragBox.startDrag(false,new Rectangle(this.x + _offSetX,this.y + _offSetY,0,_scrubBarTrack.height - _dragBox.height));			}			_dragBox.dispatchEvent(new NpScrollBarEvent(NpScrollBarEvent.DRAG_PRESS,true, true, _percentChange));			stage.addEventListener( MouseEvent.MOUSE_MOVE, updatePercent );		}		//--------------------------------------		// HANDLE DRAG HANDLE RELEASE		//--------------------------------------		private function _dragBoxRelease( event:MouseEvent ):void {			_dragBox.stopDrag();			stage.removeEventListener( MouseEvent.MOUSE_MOVE, updatePercent );			_dragBox.dispatchEvent(new NpScrollBarEvent(NpScrollBarEvent.DRAG_RELEASE,true, true, undefined));		}		//--------------------------------------		// HANDLE DRAG ROLLOVER AND ROLLOUT - DISPATCH CUSTOM EVENT		//--------------------------------------		private function _dragBoxOut(event:MouseEvent):void {			_dragBox.dispatchEvent(new NpScrollBarEvent(NpScrollBarEvent.DRAG_ROLL_OUT,true, true, undefined));		}		private function _dragBoxOver(event:MouseEvent):void {			_dragBox.dispatchEvent(new NpScrollBarEvent(NpScrollBarEvent.DRAG_ROLL_OVER,true, true, undefined));		}		//--------------------------------------		// HANDLE SLIDERBAR ROLLOVER AND ROLLOUT - REDISPATCH EVENT		//--------------------------------------		private function sliderBarOver(event:MouseEvent):void {			dispatchEvent(event);		}		private function sliderBarOff(event:MouseEvent):void {			dispatchEvent(event);		}		//--------------------------------------		// CHECK SCROLL BOUNDS METHOD		//--------------------------------------		private function checkBounds(event:TweenEvent):void {			if(_updateValuesOnTween) updatePercent();		}				private function cleanUpTween(event:TweenEvent):void {			_myTween.removeEventListener(TweenEvent.MOTION_CHANGE, checkBounds);			_myTween.removeEventListener(TweenEvent.MOTION_FINISH, cleanUpTween);		}		//--------------------------------------		// TWEENING METHOD		//--------------------------------------		private function doTween(_targetPos:Number, update:Boolean = true):void {			if (_scrollDirection == "horizontal") {				_target = _usingDefaults ? (_slideBarWidth-_dragBox.width)*_targetPos : ((_slideBarWidth-_dragBox.width)*_targetPos)+_scrubBarTrack.getBounds(stage).x;			}			else {				_target = _usingDefaults ? (_slideBarHeight-_dragBox.height)*_targetPos : ((_slideBarHeight-_dragBox.height)*_targetPos)+_scrubBarTrack.y;			}			_scrollDirection == "horizontal" ? _myTween = new Tween(_dragBox,"x",Strong.easeOut,_dragBox.x,_target,20,false) : _myTween = new Tween(_dragBox,"y",Strong.easeOut,_dragBox.y,_target,20,false);			//set internal var that determines if we dispatch the scrollChange event.			_updateValuesOnTween = update;			_myTween.addEventListener(TweenEvent.MOTION_CHANGE, checkBounds);			_myTween.addEventListener(TweenEvent.MOTION_FINISH, cleanUpTween);		}		//--------------------------------------		// REMOVED FROM STAGE - DO THE CLEANUP		//--------------------------------------		private function handleStageRemove(event:Event):void {			try {								if(_myTween != null) {					if (_myTween.isPlaying) {						_myTween.stop(),						_myTween.removeEventListener(TweenEvent.MOTION_CHANGE, checkBounds);					}				}								_dragBox.removeEventListener( MouseEvent.MOUSE_DOWN, _dragBoxPress );				stage.removeEventListener( MouseEvent.MOUSE_UP, _dragBoxRelease );				stage.removeEventListener( MouseEvent.MOUSE_MOVE, updatePercent );				_dragBox.removeEventListener(MouseEvent.ROLL_OUT, _dragBoxOut);				_dragBox.removeEventListener(MouseEvent.ROLL_OVER, _dragBoxOver);				removeChild(_scrubBarTrack);				removeChild(_dragBox);				removeEventListener(Event.REMOVED_FROM_STAGE, handleStageRemove);			} catch (error:Error) {				trace("Damn, there was an error removing scroll bar content "+error);			}		}	}}